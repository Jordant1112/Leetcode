### Binary Search Template

## Most Generalized Binary Search:
 def binary_search(array) -> int:
  def condition(value) -> bool:
    pass
   left, right = 0, len(array)
   while left < right:
    mid = left + (right - left) //2
    if condition(mid):
      right = mid
    else:
      left = mid+1
   return left
   
https://weixia.info/binary-search-template.html   
### Three parts of Binary Search
1). Pre-processing - Sort if collection is unsorted
2). Binary Search - Using a loop or recursion to divide search space in half after each comparison
3). Post-processing - Determine viable candidates in the remaining space.


### Template 4 ###
def binarySearch(nums, target):
    """
    :type nums: List[int]
    :type target: int
    :rtype: int
    """
    if len(nums) == 0:
        return -1

    left, right = 0, len(nums)
    while left < right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid

    # Post-processing:
    # End Condition: left == right
    if left != len(nums) and nums[left] == target:
        return left
    return -1
It is used to search for an element or condition which requires accessing the current index and its immediate right neighbor’s index in the array.


### Template  5 ####
def binarySearch(nums, target):
    """
    :type nums: List[int]
    :type target: int
    :rtype: int
    """
    if len(nums) == 0:
        return -1

    left, right = 0, len(nums) - 1
    while left + 1 < right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid
        else:
            right = mid

    # Post-processing:
    # End Condition: left + 1 == right
    if nums[left] == target: return left
    if nums[right] == target: return right
    return -1
It is used to search for an element or condition which requires accessing the current index and its immediate left and right neighbor’s index in the array.    
  


def binary_search(self, nums, target):
  if not nums:
    return -1
  start, end = 0, len(nums)-1
  while start +1 < end:
    mid = start + (end - start) //2
    if nums[mid] < target:
      start = mid
    elif nums[mid] == target:
      end = mid
    else:
      end = mid
  if nums[start] == target:
    return start
  if nums[end] == target:
    return end
  return -1
  
  




### 875 Koko Eating Bananas
Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.
Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.
Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return.
Return the minimum integer k such that she can eat all the bananas within h hours.
Input: piles = [3,6,7,11], h = 8
Output: 4
Input: piles = [30,11,23,4,20], h = 5
Output: 30

def minEatingSpeed(self, piles: List[int], h: int) -> int:
  def possible(k):
    return sum((p-1)/ k +1 for p in piles) <= H
  
  l , r = 1, max(piles)
  while l < r:
    mid = l + (r-l)//2
    if possible(mid):
      r = mid
    else:
      l = mid + 1
  
  return l
  
  
##1099 Two Sum Less Than K
Input: nums = [34,23,1,24,75,33,54,8], k = 60
Output: 58
Explanation: We can use 34 and 24 to sum 58 which is less than 60.

Input: nums = [10,20,30], k = 15
Output: -1
Explanation: In this case it is not possible to get a pair sum less that 15.

def twoSumLessThanK(self, nums: List[int], k: int) -> int:
  nums.sort()
  l = 0
  r = len(nums)-1
  ans = -1
  while l < r:
    mid = l + (r-l)//2
    if nums[l] + nums[r] < k:
      ans = max(ans, nums[l]+nums[r])
      l += 1
    else:
      r -=1
   return ans
   
   
###1539 Kth Missing Positive Number
Given an array arr of positive integers sorted in a strictly increasing order, and an integer k.
Find the kth positive integer that is missing from this array.
Input: arr = [2,3,4,7,11], k = 5
Output: 9
Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9.

Explanation and thoughts:
I really like this problem, because you do not stop when you find linear solution, and you can do better! What can be better, than linear solution? Usually it is solution with complexity O(log n). Now, we have two good indicators, that we need to use binary search: sorted data and O(log n) complexity. Let us look for the following example for more understanding:
2, 3, 4, 7, 11, 12 and k = 5. We need to find place, of k-th missing positive number, so, let us create virtual list (virtual, because we will not compute it full, but only elements we need):

B = [2 - 1, 3 - 2, 4 - 3, 7 - 4, 11 - 5, 12 - 6] = [1, 1, 1, 3, 6, 6].

What this list represents is how many missing numbers we have for each inex: for first number we have missing number [1], for next two iterations also, when we add 7, we have 3 missing numbers: [1, 5, 6], when we add 11, we have 6 missing numbers: [1, 5, 6, 8, 9, 10]. How we evalaute values of list B? Very easy, it is just A[i] - i - 1.
What we need to find now in array B: first element, which is greater or equal than k. In our example, we have [1, 1, 1, 3, 6, 6]. We will find it with binary search: this element have index end = 4. Finally, we need to go back to original data, we have

arr = [2, 3, 4, 7, 11, 12]
B = [1, 1, 1, 3, 6, 6]

So, what we now know that our answer is between numbers 7 and 11 and it is equal to arr[end] - (B[end] - k + 1), where the second part is how many steps we need to make backward. Using B[end] = arr[end] - end - 1, we have end + k, we need to return.

def findKthPositive(self, arr: List[int], k:int) -> int:
  l, r = 0, len(arr)
  while l < r:
    mid = l + (r-l)//2
    if arr[mid] - mid -1 < k:
      l = mid+1
    else:
      r = mid
  return r + k
 
 
## 441 Arranging Coins
You have n coins and you want to build a staircase with these coins. 
The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.
Given the integer n, return the number of complete rows of the staircase you will build.
Input: n = 5
Output: 2
Explanation: Because the 3rd row is incomplete, we return 2.
################
Note: The start should be 1 in this case
################
class Solution:
    def arrangeCoins(self, n: int) -> int:
        lo, hi = 1,n
        while lo + 1 < hi:
            mid = lo + (hi-lo)//2
            k_rows = mid*(mid+1)//2
            if k_rows == n:
                return mid
            elif k_rows < n:
                lo = mid
            else:
                hi = mid
        return min(lo,hi)    

1011. Capacity To Ship Packages Within D Days
A conveyor belt has packages that must be shipped from one port to another within days days.
The ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). 
We may not load more weight than the maximum weight capacity of the ship.
Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within days days.
Input: weights = [1,2,3,4,5,6,7,8,9,10], days = 5
Output: 15
Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:
1st day: 1, 2, 3, 4, 5
2nd day: 6, 7
3rd day: 8
4th day: 9
5th day: 10


class Solution:
 def shipWithinDays(self, weights: List[int], days: int) -> int:
  l, r  = max(weights), sum(weights)   
  self.D = days
  while l < r:
   mid = l + (r-l)//2
   if self.capacity(weights, mid):
     r = mid
   else:
     l = mid + 1
 return l
   
   
   
 def capacity(self, weights, capacity):
  total = 0
  days = 1
  for weight in weights:
   total += weight
   if total > capacity:
    total = weight
    days += 1
    if days > self.D:
     return False
  return True


## 74 Search a 2D Matrix
Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:
Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.
 
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
Output: true
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
Output: false


class Solution:
 def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
   m = len(matrix)
   n = len(matrix[0])
   if m == 0:
    return False
    
   l, r = 0, m*n-1
   while l <= r:
    mid = l + (r-l)//2
    if target == matrix[mid//n][mid%n]:
      return True
    else:
      if target < matrix[mid//n][mid % n]:
        r = mid -1
      else:
       l = mid + 1
  return False
   
   
   
   
   
   











