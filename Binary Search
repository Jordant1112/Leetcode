### Binary Search Template

## Most Generalized Binary Search:
 def binary_search(array) -> int:
  def condition(value) -> bool:
    pass
   left, right = 0, len(array)
   while left < right:
    mid = left + (right - left) //2
    if condition(mid):
      right = mid
    else:
      left = mid+1
   return left
   
https://weixia.info/binary-search-template.html   
### Three parts of Binary Search
1). Pre-processing - Sort if collection is unsorted
2). Binary Search - Using a loop or recursion to divide search space in half after each comparison
3). Post-processing - Determine viable candidates in the remaining space.


### Template 4 ###
def binarySearch(nums, target):
    """
    :type nums: List[int]
    :type target: int
    :rtype: int
    """
    if len(nums) == 0:
        return -1

    left, right = 0, len(nums)
    while left < right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid

    # Post-processing:
    # End Condition: left == right
    if left != len(nums) and nums[left] == target:
        return left
    return -1
It is used to search for an element or condition which requires accessing the current index and its immediate right neighbor’s index in the array.


### Template  5 ####
def binarySearch(nums, target):
    """
    :type nums: List[int]
    :type target: int
    :rtype: int
    """
    if len(nums) == 0:
        return -1

    left, right = 0, len(nums) - 1
    while left + 1 < right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid
        else:
            right = mid

    # Post-processing:
    # End Condition: left + 1 == right
    if nums[left] == target: return left
    if nums[right] == target: return right
    return -1
It is used to search for an element or condition which requires accessing the current index and its immediate left and right neighbor’s index in the array.    
  


def binary_search(self, nums, target):
  if not nums:
    return -1
  start, end = 0, len(nums)-1
  while start +1 < end:
    mid = start + (end - start) //2
    if nums[mid] < target:
      start = mid
    elif nums[mid] == target:
      end = mid
    else:
      end = mid
  if nums[start] == target:
    return start
  if nums[end] == target:
    return end
  return -1
  
  




### 875 Koko Eating Bananas
Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.
Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.
Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return.
Return the minimum integer k such that she can eat all the bananas within h hours.
Input: piles = [3,6,7,11], h = 8
Output: 4
Input: piles = [30,11,23,4,20], h = 5
Output: 30

def minEatingSpeed(self, piles: List[int], h: int) -> int:
  def possible(k):
    return sum((p-1)/ k +1 for p in piles) <= H
  
  l , r = 1, max(piles)
  while l < r:
    mid = l + (r-l)//2
    if possible(mid):
      r = mid
    else:
      l = mid + 1
  
  return l
  
  
##1099 Two Sum Less Than K
Input: nums = [34,23,1,24,75,33,54,8], k = 60
Output: 58
Explanation: We can use 34 and 24 to sum 58 which is less than 60.

Input: nums = [10,20,30], k = 15
Output: -1
Explanation: In this case it is not possible to get a pair sum less that 15.

def twoSumLessThanK(self, nums: List[int], k: int) -> int:
  nums.sort()
  l = 0
  r = len(nums)-1
  ans = -1
  while l < r:
    mid = l + (r-l)//2
    if nums[l] + nums[r] < k:
      ans = max(ans, nums[l]+nums[r])
      l += 1
    else:
      r -=1
   return ans
   
   
###1539 Kth Missing Positive Number
Given an array arr of positive integers sorted in a strictly increasing order, and an integer k.
Find the kth positive integer that is missing from this array.
Input: arr = [2,3,4,7,11], k = 5
Output: 9
Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9.

Explanation and thoughts:
I really like this problem, because you do not stop when you find linear solution, and you can do better! What can be better, than linear solution? Usually it is solution with complexity O(log n). Now, we have two good indicators, that we need to use binary search: sorted data and O(log n) complexity. Let us look for the following example for more understanding:
2, 3, 4, 7, 11, 12 and k = 5. We need to find place, of k-th missing positive number, so, let us create virtual list (virtual, because we will not compute it full, but only elements we need):

B = [2 - 1, 3 - 2, 4 - 3, 7 - 4, 11 - 5, 12 - 6] = [1, 1, 1, 3, 6, 6].

What this list represents is how many missing numbers we have for each inex: for first number we have missing number [1], for next two iterations also, when we add 7, we have 3 missing numbers: [1, 5, 6], when we add 11, we have 6 missing numbers: [1, 5, 6, 8, 9, 10]. How we evalaute values of list B? Very easy, it is just A[i] - i - 1.
What we need to find now in array B: first element, which is greater or equal than k. In our example, we have [1, 1, 1, 3, 6, 6]. We will find it with binary search: this element have index end = 4. Finally, we need to go back to original data, we have

arr = [2, 3, 4, 7, 11, 12]
B = [1, 1, 1, 3, 6, 6]

So, what we now know that our answer is between numbers 7 and 11 and it is equal to arr[end] - (B[end] - k + 1), where the second part is how many steps we need to make backward. Using B[end] = arr[end] - end - 1, we have end + k, we need to return.

def findKthPositive(self, arr: List[int], k:int) -> int:
  l, r = 0, len(arr)
  while l < r:
    mid = l + (r-l)//2
    if arr[mid] - mid -1 < k:
      l = mid+1
    else:
      r = mid
  return r + k
 
 
## 441 Arranging Coins
You have n coins and you want to build a staircase with these coins. 
The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.
Given the integer n, return the number of complete rows of the staircase you will build.
Input: n = 5
Output: 2
Explanation: Because the 3rd row is incomplete, we return 2.
################
Note: The start should be 1 in this case
################
class Solution:
    def arrangeCoins(self, n: int) -> int:
        lo, hi = 1,n
        while lo + 1 < hi:
            mid = lo + (hi-lo)//2
            k_rows = mid*(mid+1)//2
            if k_rows == n:
                return mid
            elif k_rows < n:
                lo = mid
            else:
                hi = mid
        return min(lo,hi)    

1011. Capacity To Ship Packages Within D Days
A conveyor belt has packages that must be shipped from one port to another within days days.
The ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). 
We may not load more weight than the maximum weight capacity of the ship.
Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within days days.
Input: weights = [1,2,3,4,5,6,7,8,9,10], days = 5
Output: 15
Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:
1st day: 1, 2, 3, 4, 5
2nd day: 6, 7
3rd day: 8
4th day: 9
5th day: 10


class Solution:
 def shipWithinDays(self, weights: List[int], days: int) -> int:
  l, r  = max(weights), sum(weights)   
  self.D = days
  while l < r:
   mid = l + (r-l)//2
   if self.capacity(weights, mid):
     r = mid
   else:
     l = mid + 1
 return l
   
   
   
 def capacity(self, weights, capacity):
  total = 0
  days = 1
  for weight in weights:
   total += weight
   if total > capacity:
    total = weight
    days += 1
    if days > self.D:
     return False
  return True


## 74 Search a 2D Matrix
Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:
Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.
 
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
Output: true
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
Output: false


class Solution:
 def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
   m = len(matrix)
   n = len(matrix[0])
   if m == 0:
    return False
    
   l, r = 0, m*n-1
   while l <= r:
    mid = l + (r-l)//2
    if target == matrix[mid//n][mid%n]:
      return True
    else:
      if target < matrix[mid//n][mid % n]:
        r = mid -1
      else:
       l = mid + 1
  return False
   
### 888 Fair Candy Swap
Alice and Bob have a different total number of candies. 
You are given two integer arrays aliceSizes and bobSizes where aliceSizes[i] is the number of candies of the ith box of candy that Alice has and bobSizes[j]
is the number of candies of the jth box of candy that Bob has.
Since they are friends, they would like to exchange one candy box each so that after the exchange, they both have the same total amount of candy.
The total amount of candy a person has is the sum of the number of candies in each box they have.
Return an integer array answer where answer[0] is the number of candies in the box that Alice must exchange, 
and answer[1] is the number of candies in the box that Bob must exchange. If there are multiple answers, you may return any one of them. 
It is guaranteed that at least one answer exists.
   
   
Input: aliceSizes = [1,1], bobSizes = [2,2]
Output: [1,2]

class Solution:
  def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:
        aliceSizes.sort()
        bobSizes.sort()
        sumalice = sum(aliceSizes)
        sumbob = sum(bobSizes)
        
        for i in range(len(aliceSizes)):
            l = 0
            r = len(bobSizes)-1
        
            while l <= r:
                mid = l + (r-l)//2
                if sumalice - aliceSizes[i] + bobSizes[mid] == sumbob+ aliceSizes[i] -\
                bobSizes[mid]:
                    ans = []
                    ans.append(aliceSizes[i])
                    ans.append(bobSizes[mid])
                    return ans
                elif sumalice - aliceSizes[i] + bobSizes[mid] < sumbob+ aliceSizes[i] -\
                bobSizes[mid]:
                    l = mid +1
                else:
                    r = mid -1
            
   
## 475. Heaters
Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses.
Every house can be warmed, as long as the house is within the heater's warm radius range. 
Given the positions of houses and heaters on a horizontal line, return the minimum radius standard of heaters so that those heaters could cover all houses.
Notice that all the heaters follow your radius standard, and the warm radius will the same.

Input: houses = [1,2,3], heaters = [2]
Output: 1
Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.

Input: houses = [1,2,3,4], heaters = [1,4]
Output: 1
Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.




class Solution:
 def findRadius(self, houses: List[int], heaters: List[int]) -> int:
  houses.sort()
  heaters = [float('-inf')] + sorted(heaters) + [float('inf')]
  r = 0
  for h in houses:
   i = bisect.bisect(heaters, h)
   r = max(r, min(h - heaters[i-1], heaters[i] - h))
  
  return r
  
  
class Solution(object):
    def findRadius(self, houses, heaters):
        """
        :type houses: List[int]
        :type heaters: List[int]
        :rtype: int
        """
        res = 0
        heaters.sort()
        for houseNum in houses:
            indx =  self.binary_search(heaters, houseNum)
            if indx == len(heaters):
                res = max(res, houseNum - heaters[-1])
            elif indx == 0: 
                res = max(res, heaters[0] - houseNum)
            else:
                 res = max(res, min(heaters[indx] - houseNum, houseNum - heaters[indx-1]))
        return res
    def binary_search(self, heaters, target):
        l = 0
        r = len(heaters)-1
        while l <= r:
            mid = l + (r-l)//2
            if  target > heaters[mid]:
                l = mid+1
            else:
                r = mid-1
        return l
                  

### 1182 Shortest Distance to Target Color

You are given an array colors, in which there are three colors: 1, 2 and 3.
You are also given some queries. Each query consists of two integers i and c, return the shortest distance between the given index i and the target color c. 
If there is no solution return -1.

Input: colors = [1,1,2,1,3,2,2,3,3], queries = [[1,3],[2,2],[6,1]]
Output: [3,0,3]
Explanation: 
The nearest 3 from index 1 is at index 4 (3 steps away).
The nearest 2 from index 2 is at index 2 itself (0 steps away).
The nearest 1 from index 6 is at index 3 (3 steps away).

Input: colors = [1,2], queries = [[0,3]]
Output: [-1]
Explanation: There is no 3 in the array.

class Solution:
 def shortestDistanceColor(self, colors: List[int], queries: List[List[int]]) -> List[int]:
      h = collections.defaultdict(list)
      for idx, color in enumerate(colors):
        h[color].append(i)
      
      res = []
      for i, (idx, color) in enumerate(queries):
        if color not in h:
           res.append(-1)
           continue
        index_list = h[color]
        insert = bisect.bisect(index_list, idx)
        ###Note: need to check if the insert position is out of bound
        left_nearest = abs(index_list[max(0, insert-1)] - idx)
        right_nearest = abs(index_list[min(insert, len(index_list)-1)] - idx)
        res.append(right_nearest, left_nearest)
      return res
        


## 1060 Missing Element in Sorted Array

Given an integer array nums which is sorted in ascending order and all of its elements are unique and given also an integer k, 
return the kth missing number starting from the leftmost number of the array.

Input: nums = [4,7,9,10], k = 1
Output: 5
Explanation: The first missing number is 5.

Input: nums = [4,7,9,10], k = 3
Output: 8
Explanation: The missing numbers are [5,6,8,...], hence the third missing number is 8.

class Solution:
 def missingElement(self, nums: List[int], k:int) -> int:
   diff = nums[-1] - nums[0] + 1
   missing = diff - len(nums)
   if k > missing:
     return nums[-1] + k - missing
   
   left = 0 
   right = len(nums)-1
   while left +1 < right:
     m = left + (right - left)//2
     missing = nums[m] - nums[left] - m + left
     if missing < k:
      left = m
      k -= missing     ## keyKEY: move left forward, we need to minus the missing words of this range
     else:
      right = m
   return nums[left] + k








