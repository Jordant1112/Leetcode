## Binary Tree Divide_conquer Template:
def divide_conquer(root):
  if root is None:
    return ...
  left_result = divide_conquer(node.left)
  right_result = divide_conquer(node.right)
  result = merge left_result and right_result to get merged result
  return result
  
## BST Iterator
def inorder_traversal(root):
  if root is None:
    return []
  ##创建一个dummy node, 右指针指向root 并放到stack里， 此时stack的栈顶dummy 是iterator的当前位置
  dummy = TreeNode(0)
  dummy.right = root
  stack = [dummy]
 
  inorder = []
  ## 每次讲iterator挪到下一个点， 也就是调整stack使得栈顶到下一个点
  while stack:
    node = stack.pop()
    if node.right：
      node = node.right
      while node:
        stack.append(node)
        node = node.left
    if stack:
      inorder.append(stack[-1])
  return inorder
  
### Implementing a BST in Python
Step 1 BSTNode Class

class BSTNode:
  def __init__(self, val = None):
    self.left = None
    self.right = None
    self.val = val

Step 2 -- Insert
  def insert(self, val):
    if not self.val:
      self.val = val
      return
    if self.val == val:
      return
    if val < self.val:
      if self.left:
        self.left.insert(val)
        return
      self.left = BSTNode(val)
      return
    if self.right:
      self.right.insert(val)
      return
    self.right = BSTNode(val)
    
Step 3-- Get Min and Get Max
  def get_min(self):
    current = self
    while current.left is not None:
      current = current.left
    return current.val
    
  def get_max(self):
    current = self
    while current.right is not None:
      current = current.right
    return current.val
    
Step 4 -- Delete
  
  def delete(self, val):
    if self == None:
      return self
    if val < self.val:
      self.left = self.left.delete(val)
    if val > self.val:
      self.right = self.right.delete(val)
    if self.right == None:
      return self.left
    if self.left == None:
      return self.right
    min_larger_node = self.right
    while min_larger_node.left:
      min_larger_node = min_larger_node.left
    self.val = min_larger_node.val
    self.right = self.right.delete(min_larger_node.val)
    return self
    
 Step 5 -- Exists
 def exists(self, val):
    if val == self.val:
      return True
    
    if val < self.val:
      if self.left == None:
        return False
      return self.left.exists(val)
    
    if self.right == None:
      return False
    return self.right.exists(val)
 

Step 6-- Inorder
def inorder(self, vals):
  if self.left is not None:
    self.left.inorder(vals)
  if self.val is not None:
    vals.append(self.val)
  if self.right is not None:
    self.right.inorder(vals)
  return vals
  
Step 7 -- Preorder
def preorder(self,vals):
  if self.val is not None:
    vals.append(self.val)
  if self.left is not None:
    self.left.preorder(vals)
  if self.right is not None:
    self.right.preorder(vals)
  return vals

Step 8 -- Postorder
def postorder(self, vals):
  if self.left is not None:
    self.left.postorder(vals)
  if self.right is not None:
    self.right.postorder(vals)
  if self.val is not None:
    vals.append(self.val)
  return vals



## 938 Range Sum of BST
class Solution:
  def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:
    ans = []
    self.inorder(root,ans,low,high)
    return sum(ans)
  
  def inorder(self, root, ans, low,high):
    if root:
      if low < root.val:
        self.inorder(root.left, ans, low, high)
      if low <= root.val <= high:
        ans.append(root.val)
      if high > root.val:
        self.inorder(root.right,ans, low, high)
 


## 1469 Find All The Lonely Nodes
class Solution:
  def getLonelyNodes(self, root: Optional[TreeNode]) -> List[int]:
    ans = []
    self.node(root, ans)
    return ans
    
  def node(self, root, ans):
    if root:
      if root.left and root.right is None:
        ans.append(root.left.val)
      if root.right and root.left is None:
        ans.append(root.right.val)
      if root.left:
        self.node(root.left, ans)
      if root.right:
        self.node(root.right, ans)
    
## 897 Increasing Order Search Tree
class Solution:
  def increasingBST(self, root:TreeNode) -> TreeNode:
    vals = []
    def dfs(root):
      if not root:
        return
      dfs(root.left)
      vals.append(root.val)
      dfs(root.right)
    
    dfs(root)
    answer = tmp = TreeNode(val = vals[0])
    
    for i in vals[1:]:
      tmp.right = TreeNode(val = i)
      tmp = tmp.right
    return answer

## 700 Search in a Binary Search Tree
You are given the root of a binary search tree (BST) and an integer val.
Find the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.
## Solution No.1 (recursive)
class Solution:
  def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
    if root is None or root.val == val:
      return root
    if root:
      if root.val > val:
        return self.searchBST(root.left, val)
      else:
        return self.searchBST(root.right,val)
 
 ## Solutioan No.2   (recursive)
 class Solution:
  def helper(self, root):
    if not root or root.val == self.val:
      self.Found = root
      return root
    if root.val > val:
      return self.helper(root.left)
    if root.val < val:
      return self.helper(root.right)
  def searchBST(self,root,val):
    self.val = val
    self.Found = None
    self.helper(root)
    return self.Found

## Solution No.3 (iterative)
class Solution:
  def searchBST(self, root, TreeNode, val:int) -> TreeNode:
    while root is not None and root.val != val:
      if root.val > val:
        root = root.left
      else:
        root = root.right
    return root
   
 ## 617 Merge Two Binary Trees
 You are given two binary trees root1 and root2.

Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.
You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node.
Otherwise, the NOT null node will be used as the node of the new tree.
Return the merged tree.

## Solution 1 Recursive
class Solution:
  def mergeTrees(self, root1: Optional[TreeNode], root2: optional[TreeNode]) -> Optional[TreeNode]:
    if not root1:
      return root2
    if not root2:
      return root1
    root1.val += root2.val
    root1.left = mergeTrees(root1.left, root2.left)
    root1.right = mergeTrees(root1.right, root2.right)
    return root1
 
## Solution 2 Iterative
 class Solution
     def mergeTrees(self, root1: Optional[TreeNode], root2: optional[TreeNode]) -> Optional[TreeNode]:
        if root1 is None:
          return root2
        
        stack = [(root1, root2)]
        while stack:
          s1, s2 = stack.pop()
          if s2 is None:
            continue
          s1.val += s2.val
          if s1.right is None:
            s1.right = s2.right
          else:
            stack.append((s1.right, s2.right))
          if s1.left is None:
            s1.left = s2.left
          else:
            stack.append(s1.left, s2.left)
        
        return root1

## 530 Minimum Absolute Difference in BST
## Solution 1
class Solution:
  def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
    ans = []
    def dfs(root, ans):
      if not root:
        return
      if root:
        if root.left:
          dfs(root.left, ans)
        ans.append(root.val)
        if root.right:
          dfs(root.right, ans)
    dfs(root,ans)
    k = 99999
    for i,j in zip(ans, ans[1:]):
      k = min(k, abs(i-j))
    return k
 
## Solution 2
def getMinimumDifference(self, root):
  self.ans = 1e9
  self.prev = None
  
  def search(node):
    if node.left:
      search(node.left)
    if self.prev is not None:
      self.ans = min(self.min, node.val - self.prev)
    self.prev = node.val
    if node.right:
      search(node.right)
   search(root)
   return self.ans
   
## 226 Invert Binary Tree
Given the root of a binary tree, invert the tree and return its root
# recursive solution
class Solution:
  def invertTree(self, root:Optional[TreeNode]) -> Optional[TreeNode]:
    if not root:
      return root
    tmp = root.right
    root.right  = root.left
    root.left = tmp
    
    self.invertTree(root.left)
    self.invertTree(root.right)
    return root
 
## iterative solution 
class Solution:
  def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
    if not root:
      return root
    stack = [root]
    while stack:
      node = stack.pop()
      if node:
        node.right, node.left = node.left, node.right
        stack += node.left, node.right
      #################alternative way ##################
      node.right , node.left = node.left, node.right
      if node.right: stack.append(node.right)
      if node.left: stack.append(node.left)
    return root

## 1022 Sum of Root To Leaf Binary Numbers
You are given the root of a binary tree where each node has a value 0 or 1.
Each root-to-leaf path represents a binary number starting with the most significant bit.
For example, if the path is 0 -> 1 -> 1 -> 0 -> 1, then this could represent 01101 in binary, which is 13.
For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.
Return the sum of these numbers. The answer is guaranteed to fit in a 32-bits integer.

## recursive solution
class Solution:
  def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:
    if not root:
      return root
    output = []
    res = ''
    def traverse(root, res):
      if root:
        if root.left:
          traverse(root.left, res + str(root.val))
        if root.right:
          traverse(root.right, res + str(root.val))
        if not root.left and not root.right:
          res += str(root.val)
          output.append(int(res,2))
    
    traverse(root, res)
    return output

## iterative solution
class Solution:
  def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:
    stack = [(root, '')]
    ans = 0
    while stack:
      node, res = stack.pop(0)
      if node:
        if node.left:
          stack.append([node.left, res + str(node.val)])
        if node.right:
          stack.append([node.right, res+ str(node.val)])
        if not node.left and not node.right:
          res += str(node.val)
          ans += int(res,2)
    return ans


## 94. Binary Tree Inorder Traversal

Given the root of a binary tree, return the inorder traversal of its nodes' values.
## Recursive
class Solution:
  def inorderTraversal(self, root: TreeNode) -> List[int]:
    if root is None:
      return []
    output = []
    def inorder(root, output):
      if not root:
        return
      if root:
        if root.left:
          inorder(root.left, output)
        output.append(root.val)
        if root.right:
          inorder(root.right, output)
     inorder(root, output)
     return output
##################################### def inorder parallel:
class Solution:
  def inorderTraversal(self, root: TreeNode) -> List[int]:
    if root is None:
      return []
    self.output = []
    self.inorder(root, self.output)
    return self.output
  def inorder(self, root, output):
      if not root:
        return
      if root:
        if root.left:
          self.inorder(root.left, output)
        output.append(root.val)
        if root.right:
          self.inorder(root.right, output)


#############################################
## Iterative
def inorderTraversal(self, root):
  ans = []
  stack = []
  
  while stack or root:
    if root:
      stack.append(root)
      root = root.left
    else:
      node = stack.pop()
      ans.append(node.val)
      root = node.right
  return ans
  
  
### 653. Two Sum IV - Input is a BST 
Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target.
Input: root = [5,3,6,2,4,null,7], k = 9
Output: true
class Solution:
    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:
        if root is None:
            return False
        res = []
        def inorder(root, res):
            if root:
                if root.left:
                    inorder(root.left, res)
                res.append(root.val)
                if root.right:
                    inorder(root.right, res)
        
        inorder(root, res)
        print(res)
        for i in range(len(res)):
            val = k - res[i]
            if val in res[:i]+res[i+1:] and len(res) > 1:
                return True
        return False
##########################        
##     faster way       ##
##########################
class Solution:
    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:
        self.lst = set()
        self.k = k
        return self.dfs(root)
    
    def dfs(self,root):
        if not root:
            return False
        y = self.k - root.val
        if y in self.lst:
            return True
        else:
            self.lst.add(root.val)
            return self.dfs(root.left) or self.dfs(root.right)
## Iterative
class Solution:
    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:
        res = set()
        stack = [root]
        
        while stack:
            node = stack.pop()
            if node:
                value = k - node.val
                if value not in res:
                    res.add(node.val)
                else:
                    return True
                stack.append(node.left)
                stack.append(node.right)
        
                


### 501 Find Mode in Binary Search Tree
Input: root = [1,null,2,2]
Output: [2]

## Recursive
class Solution:
  def findMode(self, root: Optional[TreeNode]) -> List[int]:
    freq = {}
    self.preorder(root, freq)
    output = []
    max_key = int(max(freq.values()))
    for key in freq.keys():
      if freq[key] == max_key:
        output.append(key)
    return output
  
  def preorder(self, root, freq):
     if root：
        if root.val not in freq:
          freq[root.val] = 1
        else:
          freq[root.val] += 1
        self.preorder(root.left, freq)
        self.preorder(root.right, freq)
     



## Iterative
class Solution:
  def findMode(self, root: Optional[TreeNode]) -> List[int]:
    freq = {}
    output = []
    stack = [root]
    while stack:
      node = stack.pop()
      if node:
        if node.val not in freq:
          freq[node.val] = 1
        else:
          freq[node.val] += 1
        if node.left:
          stack.append(node.left)
        if node.right:
          stack.append(node.right)
      
    max_key = int(max(freq.values()))
    for key in freq.keys():
      if freq[key] == max_key:
        output.append(key)
    return output

## 783 Minimum Distance Between BST Nodes
Given the root of a Binary Search Tree (BST), return the minimum difference between the values of any two different nodes in the tree.
Input: root = [4,2,6,1,3]
Output: 1
Input: root = [1,0,48,null,null,12,49]
Output: 1

## Recursive
class Solution:
    def minDiffInBST(self, root: Optional[TreeNode]) -> int:
        
        self.ans = 1e9
        self.prev = -1e9
        def inorder(root):
            if root:
                if root.left:
                    inorder(root.left)
                self.ans = min(self.ans, root.val - self.prev )
                self.prev = root.val
                if root.right:
                    inorder(root.right)
        
        inorder(root)
        return self.ans
        
 ## Iterative
 class Solution:
    def minDiffInBST(self, root: Optional[TreeNode]) -> int:
        ans = 1e9
        prev = None
        stack = []
        node = root
        while stack or not node：
            if node:
              stack.append(node)
              node = node.left
            else:
              node = stack.pop()
              if prev and node.val - prev.val < ans:
                ans = node.val - prev.val
              prev = node
              node = node.right
         return ans
        




##235 Lowest Common Ancestor of a Binary Search Tree
Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants
(where we allow a node to be a descendant of itself).”

##Recursive
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
      def inorder(root, p,q):
        if root:
          if p.val > root.val and q.val > root.val:
            return inorder(root.right, p,q)
          elif p.val < root.val and q.val < root.val:
            return inorder(root.left,p,q)
          else:
            return root
      return inorder(root,p,q)
      
## Iterative
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
      while root：
        if p.val > root.val and q.val > root.val:
          root = root.right
        elif p.val < root.val and q.val < root.val:
          root = root.left
        else:
          return root
      

## 1214 Two Sum BSTs
Given the roots of two binary search trees, root1 and root2, 
return true if and only if there is a node in the first tree and a node in the second tree whose values sum up to a given integer target.


## Recursive
class Solution:
    def twoSumBSTs(self, root1: Optional[TreeNode], root2: Optional[TreeNode], target: int) -> bool:
        
        self.output1 = []
        self.output2 = []
        self.inorder(root1, self.output1)
        self.inorder(root2, self.output2)
        i = 0
        while i < len(self.output1):
            k = target - self.output1[i]
            if k in self.output2:
                return True
            i += 1
        return False
    def inorder(self, root, output):
        if root:
            if root.left:
                self.inorder(root.left, output)
            output.append(root.val)
            if root.right:
                self.inorder(root.right, output)
    
## Iterative
class Solution:
    def twoSumBSTs(self, root1: Optional[TreeNode], root2: Optional[TreeNode], target: int) -> bool:
        stack1 = [root1]
        stack2 = [root2]
        s = set()
        
        while stack1:
            node1 = stack1.pop()
            if node1:
                if node1.left:
                    stack1.append(node1.left)
                s.add(target - node1.val)
                if node1.right:
                    stack1.append(node1.right)
        #print(s)           
        while stack2:
            node2 = stack2.pop()
            if node2:
                if node2.left:
                    stack2.append(node2.left)
                if node2.val in s:
                    return True
                if node2.right:
                    stack2.append(node2.right)
        return False

## 230 Kth Smallest Element in a BST
Given the root of a binary search tree, and an integer k, return the kth (1-indexed) smallest element in the tree.
Input: root = [3,1,4,null,2], k = 1
Output: 1

## Recursive
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        self.ans = []
        self.inorder(root)
        print(self.ans)
        return self.ans[k-1]
    
    
    
    def inorder(self, root):
        if root:
            if root.left:
                self.inorder(root.left)
            self.ans.append(root.val)
            if root.right:
                self.inorder(root.right)
                
  ## Iterative
  class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        ans = []
        stack = []
        while stack or root:
            while root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            k -=1
            if k == 0:
                return root.val
            root = root.right
        
## Second Minimum Node in a Binary Tree
class Solution:
    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:
        self.ans = []
        self.inorder(root)
        self.ans.sort()
        if len(self.ans) > 1:
            return self.ans[1]
        return -1       
    def inorder(self, root):
        if root:
            if root.left:
                self.inorder(root.left)
            if root.val not in self.ans:
                self.ans.append(root.val)
            if root.right:
                self.inorder(root.right)
 
##1973 Count Nodes Equal to Sum of Descendants
Given the root of a binary tree, return the number of nodes where the value of the node is equal to the sum of the values of its descendants.
A descendant of a node x is any node that is on the path from node x to some leaf node. The sum is considered to be 0 if the node has no descendants.
## recurisve
class Solution:
    def equalToDescendants(self, root: Optional[TreeNode]) -> int:
        self.ans = 0
        self.postorder(root)
        return self.ans
    
    def postorder(self,root):
        if not root:
            return 0
        
        s = self.postorder(root.left) + self.postorder(root.right)
        if root.val == s:
            self.ans += 1
        return s + root.val
        

## 1382 Balance a Binary Search Tree
 class Solution:
    def balanceBST(self, root: TreeNode) -> TreeNode:
        self.res = []
        self.inorder(root)
        print(self.res)
        return self.bst(self.res)  
    
    def inorder(self, root):
        if root:
            if root.left:
                self.inorder(root.left)
            self.res.append(root.val)
            if root.right:
                self.inorder(root.right)
    def bst(self, res):
        if not res:
            return None
        mid = len(res)//2
        root = TreeNode(res[mid])
        root.left = self.bst(res[:mid])
        root.right = self.bst(res[mid+1:])
        return root


## 701 Insert into a Binary Search Tree
## recursive
class Solution:
  def insertIntoBST(self, root: Optional[TreeNode], val:int) -> Optional[TreeNode]:
    if not root:
      return None
    if root.val < val:
      root.right = self.insertIntoBST(root.right, val)
    else:
      root.left = self.insertIntoBST(root.left, val)
    return root
    
## Iterative
class Solution:
  def insertIntoBST(self, root: Optional[TreeNode], val:int) -> Optional[TreeNode]:
    node = root
        while node:
            if node.val < val:
                if not node.right:
                    node.right = TreeNode(val)
                    return root
                else:
                    node = node.right
            else:
                if not node.left:
                    node.left = TreeNode(val)
                    return root
                else:
                    node = node.left
        return TreeNode(val)
 
 
98. Validate Binary Search Tree
Given the root of a binary tree, determine if it is a valid binary search tree (BST).
A valid BST is defined as follows:
The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.
 
## Recursive
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
      return self.validate(root)
    
    def validate(self, root, low = -inf.math, high = inf.math):
      if not root:
        return True
      if root.val <= low or root.val >= high:
        return False
      return (self.validate(root.left, low, root.val) and self.validate(root.right, root.val, high))
     
## Iterative
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
      if not root:
        return True
      stack = [(root, -inf.math, inf.math)]
      
      while stack:
        root, low, high = stack.pop()
        if not root:
          continue
        if root.val <= low or root.val >= high:
          return False
        stack.append((root.left, low, root.val))
        stack.append((root.right, root.val, high))
      return True
      
 
 
## 1973 Count Nodes Equal to Sum of Descendants
Given the root of a binary tree, return the number of nodes where the value of the node is equal to the sum of the values of its descendants.
A descendant of a node x is any node that is on the path from node x to some leaf node. The sum is considered to be 0 if the node has no descendants.
 
## Note: descendants sum is calculated from bottom to top, so naturally, we will do a post order traversal 
## Recursive
class Solution:
  def equalToDescendants(self, root:Optional[TreeNode]) -> int:
    self.ans = 0
    self.postorder(root)
    return self.ans
    
    
    
  def postorder(self,root):
    if not root:
      return 0
    s = self.postorder(root.left) + self.postorder(root.right)
    if root.val == s:
      self.ans +=1
    return s + root.val








 
 
 
      
## 99 Recover Binary Search Tree
You are given the root of a binary search tree (BST), where exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.
Follow up: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?
Input: root = [1,3,null,null,2]
Output: [3,1,null,null,2]

## Thoughts: 1). Traverse the tree In-order recorder in res=[]. 2). Swap the res[i+1] < res[i]. 3). Recover the root 

## Recursive
class Solution:
  def recoverTree(self, root: Optional[TreeNode]) -> None:
    """
    Do not return anything, modify root in-place instead.
    """
  
  
  
  def inorder(self, root):
    return self.inorder(root.left) + [root.val] + self.inorder(root.right)
  def swap_two(self, nums: List[int]) -> (int, int):
    x = y = -1
    n = len(nums)
    for i in range(n-1):
      if nums[i + 1] < nums[i]:
        y = nums[i+1]
        if x == -1:
          x = nums[i]
        else:
          break
    return x, y
  
  def recover(self, root: Optional[TreeNode], count, x, y):
    if root:
      if root.val == x or root.val == y:
        root.val = y if root.val == x else x
        count -= 1
        if count == 0:
          return 
      self.recover(root.left, count, x, y)
      self.recover(root.right, count, x, y)
    


## Iterative
## To identify swapped nodes in iterative solution, track the last node pred in the inorder traversal
(i.e. the predecessor of the current node) and compare it with current node value. If the current node value
is smaller than its predecessor pred value, the swapped node is here. 

class Solution:
  def recoverTree(self, root:TreeNode):
    x = y = pred = None
    stack = []
    
    while stack or root:
      while root:
        stack.append(root)
        root = root.left
      root = stack.pop()
      if pred and pre.val > root.val:
        y = root
        if x is None:
          x = pred
        else:
          break
      pred = root
      root = root.right
    
    x.val, y.val = y.val, x.val



## 111 Minimum Depth of Binary Tree
## DFS
class Solution:
  def minDepth(self, root: Optional[TreeNode]) -> int:
    if not root:
      return 0
    if root:
      if not root.left and not root.right:
        return 1
      if not root.left and root.right:
        return 1 + self.minDepth(root.right)
      if not root.right and root.left:
        return 1 + self.minDepth(root.left)
    return 1 + min(self.minDepth(root.left), self.minDepth(root.right))

      
## BFS
class Solution
  def minDepth(self, root):
    if not root:
      return 0
    else:
      stack, min_depth = [(1,root),], float('inf')
      
    while stack:
      depth, root = stack.pop()
      children = [root.left, root.right]
      if not any(children):
        min_depth = min(depth, min_depth)
      for c in children:
        if c:
          stack.append((depth+1, c))
    return min_depth

## 449 Serialize and deserialize BST
Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, 
or transmitted across a network connection link to be reconstructed later in the same or another computer environment.
Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. 
You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.
The encoded string should be as compact as possible.

class Codec:
  def serialize(self, root: TreeNode) -> str:
    def postorder(root): 
      return self.postorder(root.left) + self.postorder(root.right) + [root.val] if root else[]
    return ' '.join(postorder(root))
  
  def deserialize(self, data:str) -> TreeNode:
    data = [x for x in data.split(' ') if x]
    return helper(data)
  
  
  
  def helper(self, data, lower = float('-inf'), upper = float('inf')):
    if not data or data[-1] < lower or data[-1] > upper:
      return None
    val = data.pop()
    root = TreeNode(val)
    root.right = self.helper(val, upper)
    root.left = self.helper(lower, val)
    
    return root


## 538 Convert BST to Greater Tree
Given the root of a BST, convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.
As a reminder, a binary search tree is a tree that satisfies these constraints:
The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.

## recursive
class Solution:
   def __ init__(self):
    self.s = 0
    
   def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
      if root:
        self.convertBST(root.right)
        self.s += root.val
        self.convertBST(root.left)
      return root
      
      
## Iterative
class Solution:
  def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
    s = 0
    stack = []
    node = root
    while stack or node:
      while node:
        stack.append(node)
        node = node.right
      node = stack.pop()
      s += node.val
      node.val = s
      node = node.left
   return root
   
   

## 285 Inorder Successor in BST

## it is similar to finding the Inorder Successor in a Binary Tree. We should look at solution applies to any kind of binary tree.
### Approach 1 ## Iterviewers may ask to find the inorder success for a binary tree instead of BST
####Situation 1:
when the node has a right child
The inorder successor in this case is the leftmost node in the tree rooted at the right child. 
####Situation 2:
when the node doesn't have a right child
This is trickier to handle than the first case. In this case, one of the ancestors acts as the inorder successor. That ancestor can be the immediate parent,
or, it can be one of the ancestors further up the tree.

Algorithm:
1. We define two class variables for this algorithm: previous and inorderSuccessorNode. The previous variable will only be used when handling the second case
as previously explained and the inorderSuccessorNode will ultimately contain the result to be returned
2. Inside the function inorderSuccessor, we first check which of the two cases we need to handle. For that, we simply check for the presence of a right child.

The right child exists:
In this case, we assign the right child to a node called leftmost and we iterate until we reach a node (leftmost) which doesn't have a left child. We
iteratively assign leftmost = leftmost.left and that's how we will get the leftmost node in ths subtree

The right child does not exist:
1). As mentioned before, this case is trickier to handle. For this, we define another function called inorderCase2, and we will pass it a node and the node p.
2). We perform simple inorder traversal and hence, we first recurse on the left child of the node.
3). Then, when the recursion returns, we check if the class variable previous is equal to the node p. If that is the case, then it means p is the inorder predecessor of node
or in other words, the node is the inorder successor of the node p and we return from that point onwards. We assign inorderSuccessorNode to node and return from this function

3. Finally, we return the inorderSuccessorNode as our result.
    
class Solution:
  previous = None
  inorder_successor_node = None
  
  def inorderSuccessor(self, root: 'TreeNode', p: 'TreeNode') -> 'TreeNode':
    self.previous = None
    self.inorder_successor_node = None
    # Case 1: We simply need to find the leftmost node in the SUbtree rooted at p.right
    if p.right:
      leftmost = p.right
      while leftmost.left:
        leftmost = leftmost.left
      self.inorder_successor_node = leftmost
      
    # Case 2: We need to perform the standard inorder traversal and keep track of the previous node
    else:
      self.inorderCase2(root, p)
    return self.inorder_successor_node
    
    
    
  def inorderCase2(self, node: 'TreeNode', p:'TreeNode'):
    if not node:
      return
    # Recurse on the leftside
    self.inorderCase2(root.left, p)
    # Check if previous is the inorder predecessor of node
    if self.previous == p and not self.inorder_successor_node:
      self.inorder_successor_node = node
      return
    # Keeping previous up-to-date for further recursion
    self.previous = node
    # recurse the right side
    self.inorderCase2(node.right, p)
 

###Approach 2 use the BST properties
By comparing the values of the node p and the current node in the tree during the traverwsal, we can discard half of the remaining nodes
at each step, and thus, for a balanced binary search tree we can search for our inorder successor in logarithmic time rather than linear time.
That's a huge improvement over the preivous solution

## Algorithm
1. We start our traversal with the root node and continue the traversal until our current node reaches a null value i.e. 
there are no more nodes left to process.
2. At each step we compare the value of node p with that of node.
1). If p.val >= node.val that implies we can safely discard the left subtree since all the nodes there including the current node have values less than p
2). However, if p.val < node.val, that implies that the successor must lie in the left subtree and that the current node is apotential candidate for inorder
successor. Thus, we update our local variable for keeping track of the successor, successor, to node.
3). return successor

class Solution:
  def inorderSuccessor(self, root:'TreeNode', p: 'TreeNode') -> 'TreeNode':
    successor = None
    while root:
      if p.val >= root.val:
        root = root.right
      else:
        successor = root
        root = root.left
    
    return successor



## 1902 Depth of BST Given Insertion Order
You are given a 0-indexed integer array order of length n, a permutation of integers from 1 to n representing the order of insertion into a binary search tree.

A binary search tree is defined as follows:
The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.
The binary search tree is constructed as follows:

order[0] will be the root of the binary search tree.
All subsequent elements are inserted as the child of any existing node such that the binary search tree properties hold.
Return the depth of the binary search tree.

A binary tree's depth is the number of nodes along the longest path from the root node down to the farthest leaf node.


class Solution:
  def maxDepthBST(self, order: List[int]) -> int:
    def check(order):
      if len(order) <= 1:
        return 1
      root = order[0]
      left, right = [], []
      for i in order[1:]:
        if i > root:
          right.append(i)
        else:
          left.append(i)
      return 1 + max(check(left), check(right))
      
    if max(order) == order[0] and min(order) == order[-1] or min(order) == order[0] and max(order) == order[-1]:
      return len(order)
    return check(order)

## 96 Unique BST
Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.

Input: n = 3
Output: 5

Note: Cartesian Product. Dynamic Programming question
F(3,7), based on the root of 3, 7 nodes. F(3,7) = G(2)* G(4)
Formula:
G(n) = sum(F(i,n)) where i from 1 to n
F(i,n) = G(i-1) * G(n-i)

class Solution:
  def numTrees(self, n: int) -> int:
    G = [0]*(n+1)
    G[0], G[1] = 1,1
    for i in range(2,n+1):
      for j in range(1,i+1):
        G[i] +=G[j-1]*G[i-j]
    return G[n]

#Catalan Numbers: (2n)! / n!/ (n+1)!







