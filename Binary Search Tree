## Binary Tree Divide_conquer Template:
def divide_conquer(root):
  if root is None:
    return ...
  left_result = divide_conquer(node.left)
  right_result = divide_conquer(node.right)
  result = merge left_result and right_result to get merged result
  return result
  
## BST Iterator
def inorder_traversal(root):
  if root is None:
    return []
  ##创建一个dummy node, 右指针指向root 并放到stack里， 此时stack的栈顶dummy 是iterator的当前位置
  dummy = TreeNode(0)
  dummy.right = root
  stack = [dummy]
 
  inorder = []
  ## 每次讲iterator挪到下一个点， 也就是调整stack使得栈顶到下一个点
  while stack:
    node = stack.pop()
    if node.right：
      node = node.right
      while node:
        stack.append(node)
        node = node.left
    if stack:
      inorder.append(stack[-1])
  return inorder
  
### Implementing a BST in Python
Step 1 BSTNode Class

class BSTNode:
  def __init__(self, val = None):
    self.left = None
    self.right = None
    self.val = val

Step 2 -- Insert
  def insert(self, val):
    if not self.val:
      self.val = val
      return
    if self.val == val:
      return
    if val < self.val:
      if self.left:
        self.left.insert(val)
        return
      self.left = BSTNode(val)
      return
    if self.right:
      self.right.insert(val)
      return
    self.right = BSTNode(val)
    
Step 3-- Get Min and Get Max
  def get_min(self):
    current = self
    while current.left is not None:
      current = current.left
    return current.val
    
  def get_max(self):
    current = self
    while current.right is not None:
      current = current.right
    return current.val
    
Step 4 -- Delete
  
  def delete(self, val):
    if self == None:
      return self
    if val < self.val:
      self.left = self.left.delete(val)
    if val > self.val:
      self.right = self.right.delete(val)
    if self.right == None:
      return self.left
    if self.left == None:
      return self.right
    min_larger_node = self.right
    while min_larger_node.left:
      min_larger_node = min_larger_node.left
    self.val = min_larger_node.val
    self.right = self.right.delete(min_larger_node.val)
    return self
    
 Step 5 -- Exists
 def exists(self, val):
    if val == self.val:
      return True
    
    if val < self.val:
      if self.left == None:
        return False
      return self.left.exists(val)
    
    if self.right == None:
      return False
    return self.right.exists(val)
 

Step 6-- Inorder
def inorder(self, vals):
  if self.left is not None:
    self.left.inorder(vals)
  if self.val is not None:
    vals.append(self.val)
  if self.right is not None:
    self.right.inorder(vals)
  return vals
  
Step 7 -- Preorder
def preorder(self,vals):
  if self.val is not None:
    vals.append(self.val)
  if self.left is not None:
    self.left.preorder(vals)
  if self.right is not None:
    self.right.preorder(vals)
  return vals

Step 8 -- Postorder
def postorder(self, vals):
  if self.left is not None:
    self.left.postorder(vals)
  if self.right is not None:
    self.right.postorder(vals)
  if self.val is not None:
    vals.append(self.val)
  return vals












    
