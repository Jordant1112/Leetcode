## Binary Tree Divide_conquer Template:
def divide_conquer(root):
  if root is None:
    return ...
  left_result = divide_conquer(node.left)
  right_result = divide_conquer(node.right)
  result = merge left_result and right_result to get merged result
  return result
  
## BST Iterator
def inorder_traversal(root):
  if root is None:
    return []
  ##创建一个dummy node, 右指针指向root 并放到stack里， 此时stack的栈顶dummy 是iterator的当前位置
  dummy = TreeNode(0)
  dummy.right = root
  stack = [dummy]
 
  inorder = []
  ## 每次讲iterator挪到下一个点， 也就是调整stack使得栈顶到下一个点
  while stack:
    node = stack.pop()
    if node.right：
      node = node.right
      while node:
        stack.append(node)
        node = node.left
    if stack:
      inorder.append(stack[-1])
  return inorder
  
### Implementing a BST in Python
Step 1 BSTNode Class

class BSTNode:
  def __init__(self, val = None):
    self.left = None
    self.right = None
    self.val = val

Step 2 -- Insert
  def insert(self, val):
    if not self.val:
      self.val = val
      return
    if self.val == val:
      return
    if val < self.val:
      if self.left:
        self.left.insert(val)
        return
      self.left = BSTNode(val)
      return
    if self.right:
      self.right.insert(val)
      return
    self.right = BSTNode(val)
    
Step 3-- Get Min and Get Max
  def get_min(self):
    current = self
    while current.left is not None:
      current = current.left
    return current.val
    
  def get_max(self):
    current = self
    while current.right is not None:
      current = current.right
    return current.val
    
Step 4 -- Delete
  
  def delete(self, val):
    if self == None:
      return self
    if val < self.val:
      self.left = self.left.delete(val)
    if val > self.val:
      self.right = self.right.delete(val)
    if self.right == None:
      return self.left
    if self.left == None:
      return self.right
    min_larger_node = self.right
    while min_larger_node.left:
      min_larger_node = min_larger_node.left
    self.val = min_larger_node.val
    self.right = self.right.delete(min_larger_node.val)
    return self
    
 Step 5 -- Exists
 def exists(self, val):
    if val == self.val:
      return True
    
    if val < self.val:
      if self.left == None:
        return False
      return self.left.exists(val)
    
    if self.right == None:
      return False
    return self.right.exists(val)
 

Step 6-- Inorder
def inorder(self, vals):
  if self.left is not None:
    self.left.inorder(vals)
  if self.val is not None:
    vals.append(self.val)
  if self.right is not None:
    self.right.inorder(vals)
  return vals
  
Step 7 -- Preorder
def preorder(self,vals):
  if self.val is not None:
    vals.append(self.val)
  if self.left is not None:
    self.left.preorder(vals)
  if self.right is not None:
    self.right.preorder(vals)
  return vals

Step 8 -- Postorder
def postorder(self, vals):
  if self.left is not None:
    self.left.postorder(vals)
  if self.right is not None:
    self.right.postorder(vals)
  if self.val is not None:
    vals.append(self.val)
  return vals



## 938 Range Sum of BST
class Solution:
  def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:
    ans = []
    self.inorder(root,ans,low,high)
    return sum(ans)
  
  def inorder(self, root, ans, low,high):
    if root:
      if low < root.val:
        self.inorder(root.left, ans, low, high)
      if low <= root.val <= high:
        ans.append(root.val)
      if high > root.val:
        self.inorder(root.right,ans, low, high)
 


## 1469 Find All The Lonely Nodes
class Solution:
  def getLonelyNodes(self, root: Optional[TreeNode]) -> List[int]:
    ans = []
    self.node(root, ans)
    return ans
    
  def node(self, root, ans):
    if root:
      if root.left and root.right is None:
        ans.append(root.left.val)
      if root.right and root.left is None:
        ans.append(root.right.val)
      if root.left:
        self.node(root.left, ans)
      if root.right:
        self.node(root.right, ans)
    
## 897 Increasing Order Search Tree
class Solution:
  def increasingBST(self, root:TreeNode) -> TreeNode:
    vals = []
    def dfs(root):
      if not root:
        return
      dfs(root.left)
      vals.append(root.val)
      dfs(root.right)
    
    dfs(root)
    answer = tmp = TreeNode(val = vals[0])
    
    for i in vals[1:]:
      tmp.right = TreeNode(val = i)
      tmp = tmp.right
    return answer





    
