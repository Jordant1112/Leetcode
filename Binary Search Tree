## Binary Tree Divide_conquer Template:
def divide_conquer(root):
  if root is None:
    return ...
  left_result = divide_conquer(node.left)
  right_result = divide_conquer(node.right)
  result = merge left_result and right_result to get merged result
  return result
  
## BST Iterator
def inorder_traversal(root):
  if root is None:
    return []
  ##创建一个dummy node, 右指针指向root 并放到stack里， 此时stack的栈顶dummy 是iterator的当前位置
  dummy = TreeNode(0)
  dummy.right = root
  stack = [dummy]
 
  inorder = []
  ## 每次讲iterator挪到下一个点， 也就是调整stack使得栈顶到下一个点
  while stack:
    node = stack.pop()
    if node.right：
      node = node.right
      while node:
        stack.append(node)
        node = node.left
    if stack:
      inorder.append(stack[-1])
  return inorder
  
### Implementing a BST in Python
Step 1 BSTNode Class

class BSTNode:
  def __init__(self, val = None):
    self.left = None
    self.right = None
    self.val = val

Step 2 -- Insert
  def insert(self, val):
    if not self.val:
      self.val = val
      return
    if self.val == val:
      return
    if val < self.val:
      if self.left:
        self.left.insert(val)
        return
      self.left = BSTNode(val)
      return
    if self.right:
      self.right.insert(val)
      return
    self.right = BSTNode(val)
    
Step 3-- Get Min and Get Max
  def get_min(self):
    current = self
    while current.left is not None:
      current = current.left
    return current.val
    
  def get_max(self):
    current = self
    while current.right is not None:
      current = current.right
    return current.val
    
Step 4 -- Delete
  
  def delete(self, val):
    if self == None:
      return self
    if val < self.val:
      self.left = self.left.delete(val)
    if val > self.val:
      self.right = self.right.delete(val)
    if self.right == None:
      return self.left
    if self.left == None:
      return self.right
    min_larger_node = self.right
    while min_larger_node.left:
      min_larger_node = min_larger_node.left
    self.val = min_larger_node.val
    self.right = self.right.delete(min_larger_node.val)
    return self
    
 Step 5 -- Exists
 def exists(self, val):
    if val == self.val:
      return True
    
    if val < self.val:
      if self.left == None:
        return False
      return self.left.exists(val)
    
    if self.right == None:
      return False
    return self.right.exists(val)
 

Step 6-- Inorder
def inorder(self, vals):
  if self.left is not None:
    self.left.inorder(vals)
  if self.val is not None:
    vals.append(self.val)
  if self.right is not None:
    self.right.inorder(vals)
  return vals
  
Step 7 -- Preorder
def preorder(self,vals):
  if self.val is not None:
    vals.append(self.val)
  if self.left is not None:
    self.left.preorder(vals)
  if self.right is not None:
    self.right.preorder(vals)
  return vals

Step 8 -- Postorder
def postorder(self, vals):
  if self.left is not None:
    self.left.postorder(vals)
  if self.right is not None:
    self.right.postorder(vals)
  if self.val is not None:
    vals.append(self.val)
  return vals



## 938 Range Sum of BST
class Solution:
  def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:
    ans = []
    self.inorder(root,ans,low,high)
    return sum(ans)
  
  def inorder(self, root, ans, low,high):
    if root:
      if low < root.val:
        self.inorder(root.left, ans, low, high)
      if low <= root.val <= high:
        ans.append(root.val)
      if high > root.val:
        self.inorder(root.right,ans, low, high)
 


## 1469 Find All The Lonely Nodes
class Solution:
  def getLonelyNodes(self, root: Optional[TreeNode]) -> List[int]:
    ans = []
    self.node(root, ans)
    return ans
    
  def node(self, root, ans):
    if root:
      if root.left and root.right is None:
        ans.append(root.left.val)
      if root.right and root.left is None:
        ans.append(root.right.val)
      if root.left:
        self.node(root.left, ans)
      if root.right:
        self.node(root.right, ans)
    
## 897 Increasing Order Search Tree
class Solution:
  def increasingBST(self, root:TreeNode) -> TreeNode:
    vals = []
    def dfs(root):
      if not root:
        return
      dfs(root.left)
      vals.append(root.val)
      dfs(root.right)
    
    dfs(root)
    answer = tmp = TreeNode(val = vals[0])
    
    for i in vals[1:]:
      tmp.right = TreeNode(val = i)
      tmp = tmp.right
    return answer

## 700 Search in a Binary Search Tree
You are given the root of a binary search tree (BST) and an integer val.
Find the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.
## Solution No.1 (recursive)
class Solution:
  def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
    if root is None or root.val == val:
      return root
    if root:
      if root.val > val:
        return self.searchBST(root.left, val)
      else:
        return self.searchBST(root.right,val)
 
 ## Solutioan No.2   (recursive)
 class Solution:
  def helper(self, root):
    if not root or root.val == self.val:
      self.Found = root
      return root
    if root.val > val:
      return self.helper(root.left)
    if root.val < val:
      return self.helper(root.right)
  def searchBST(self,root,val):
    self.val = val
    self.Found = None
    self.helper(root)
    return self.Found

## Solution No.3 (iterative)
class Solution:
  def searchBST(self, root, TreeNode, val:int) -> TreeNode:
    while root is not None and root.val != val:
      if root.val > val:
        root = root.left
      else:
        root = root.right
    return root
   
 ## 617 Merge Two Binary Trees
 You are given two binary trees root1 and root2.

Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.
You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node.
Otherwise, the NOT null node will be used as the node of the new tree.
Return the merged tree.

## Solution 1 Recursive
class Solution:
  def mergeTrees(self, root1: Optional[TreeNode], root2: optional[TreeNode]) -> Optional[TreeNode]:
    if not root1:
      return root2
    if not root2:
      return root1
    root1.val += root2.val
    root1.left = mergeTrees(root1.left, root2.left)
    root1.right = mergeTrees(root1.right, root2.right)
    return root1
 
## Solution 2 Iterative
 class Solution
     def mergeTrees(self, root1: Optional[TreeNode], root2: optional[TreeNode]) -> Optional[TreeNode]:
        if root1 is None:
          return root2
        
        stack = [(root1, root2)]
        while stack:
          s1, s2 = stack.pop()
          if s2 is None:
            continue
          s1.val += s2.val
          if s1.right is None:
            s1.right = s2.right
          else:
            stack.append((s1.right, s2.right))
          if s1.left is None:
            s1.left = s2.left
          else:
            stack.append(s1.left, s2.left)
        
        return root1

## 530 Minimum Absolute Difference in BST
## Solution 1
class Solution:
  def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
    ans = []
    def dfs(root, ans):
      if not root:
        return
      if root:
        if root.left:
          dfs(root.left, ans)
        ans.append(root.val)
        if root.right:
          dfs(root.right, ans)
    dfs(root,ans)
    k = 99999
    for i,j in zip(ans, ans[1:]):
      k = min(k, abs(i-j))
    return k
 
## Solution 2
def getMinimumDifference(self, root):
  self.ans = 1e9
  self.prev = None
  
  def search(node):
    if node.left:
      search(node.left)
    if self.prev is not None:
      self.ans = min(self.min, node.val - self.prev)
    self.prev = node.val
    if node.right:
      search(node.right)
   search(root)
   return self.ans
   
## 226 Invert Binary Tree
Given the root of a binary tree, invert the tree and return its root
# recursive solution
class Solution:
  def invertTree(self, root:Optional[TreeNode]) -> Optional[TreeNode]:
    if not root:
      return root
    tmp = root.right
    root.right  = root.left
    root.left = tmp
    
    self.invertTree(root.left)
    self.invertTree(root.right)
    return root
 
## iterative solution 
class Solution:
  def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
    if not root:
      return root
    stack = [root]
    while stack:
      node = stack.pop()
      if node:
        node.right, node.left = node.left, node.right
        stack += node.left, node.right
      #################alternative way ##################
      node.right , node.left = node.left, node.right
      if node.right: stack.append(node.right)
      if node.left: stack.append(node.left)
    return root

## 1022 Sum of Root To Leaf Binary Numbers
You are given the root of a binary tree where each node has a value 0 or 1.
Each root-to-leaf path represents a binary number starting with the most significant bit.
For example, if the path is 0 -> 1 -> 1 -> 0 -> 1, then this could represent 01101 in binary, which is 13.
For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.
Return the sum of these numbers. The answer is guaranteed to fit in a 32-bits integer.

## recursive solution
class Solution:
  def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:
    if not root:
      return root
    output = []
    res = ''
    def traverse(root, res):
      if root:
        if root.left:
          traverse(root.left, res + str(root.val))
        if root.right:
          traverse(root.right, res + str(root.val))
        if not root.left and not root.right:
          res += str(root.val)
          output.append(int(res,2))
    
    traverse(root, res)
    return output

## iterative solution
class Solution:
  def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:
    stack = [(root, '')]
    ans = 0
    while stack:
      node, res = stack.pop(0)
      if node:
        if node.left:
          stack.append([node.left, res + str(node.val)])
        if node.right:
          stack.append([node.right, res+ str(node.val)])
        if not node.left and not node.right:
          res += str(node.val)
          ans += int(res,2)
    return ans


## 94. Binary Tree Inorder Traversal

Given the root of a binary tree, return the inorder traversal of its nodes' values.
## Recursive
class Solution:
  def inorderTraversal(self, root: TreeNode) -> List[int]:
    if root is None:
      return []
    output = []
    def inorder(root, output):
      if not root:
        return
      if root:
        if root.left:
          inorder(root.left, output)
        output.append(root.val)
        if root.right:
          inorder(root.right, output)
     inorder(root, output)
     return output
##################################### def inorder parallel:
class Solution:
  def inorderTraversal(self, root: TreeNode) -> List[int]:
    if root is None:
      return []
    self.output = []
    self.inorder(root, self.output)
    return self.output
  def inorder(self, root, output):
      if not root:
        return
      if root:
        if root.left:
          self.inorder(root.left, output)
        output.append(root.val)
        if root.right:
          self.inorder(root.right, output)


#############################################
## Iterative
def inorderTraversal(self, root):
  ans = []
  stack = []
  
  while stack or root:
    if root:
      stack.append(root)
      root = root.left
    else:
      node = stack.pop()
      ans.append(node.val)
      root = node.right
  return ans
  
  
### 653. Two Sum IV - Input is a BST 
Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target.
Input: root = [5,3,6,2,4,null,7], k = 9
Output: true
class Solution:
    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:
        if root is None:
            return False
        res = []
        def inorder(root, res):
            if root:
                if root.left:
                    inorder(root.left, res)
                res.append(root.val)
                if root.right:
                    inorder(root.right, res)
        
        inorder(root, res)
        print(res)
        for i in range(len(res)):
            val = k - res[i]
            if val in res[:i]+res[i+1:] and len(res) > 1:
                return True
        return False
##########################        
##     faster way       ##
##########################
class Solution:
    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:
        self.lst = set()
        self.k = k
        return self.dfs(root)
    
    def dfs(self,root):
        if not root:
            return False
        y = self.k - root.val
        if y in self.lst:
            return True
        else:
            self.lst.add(root.val)
            return self.dfs(root.left) or self.dfs(root.right)
## Iterative
class Solution:
    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:
        res = set()
        stack = [root]
        
        while stack:
            node = stack.pop()
            if node:
                value = k - node.val
                if value not in res:
                    res.add(node.val)
                else:
                    return True
                stack.append(node.left)
                stack.append(node.right)
        
                


### 501 Find Mode in Binary Search Tree
Input: root = [1,null,2,2]
Output: [2]

## Recursive
class Solution:
  def findMode(self, root: Optional[TreeNode]) -> List[int]:
    freq = {}
    self.preorder(root, freq)
    output = []
    max_key = int(max(freq.values()))
    for key in freq.keys():
      if freq[key] == max_key:
        output.append(key)
    return output
  
  def preorder(self, root, freq):
     if root：
        if root.val not in freq:
          freq[root.val] = 1
        else:
          freq[root.val] += 1
        self.preorder(root.left, freq)
        self.preorder(root.right, freq)
     



## Iterative
class Solution:
  def findMode(self, root: Optional[TreeNode]) -> List[int]:
    freq = {}
    output = []
    stack = [root]
    while stack:
      node = stack.pop()
      if node:
        if node.val not in freq:
          freq[node.val] = 1
        else:
          freq[node.val] += 1
        if node.left:
          stack.append(node.left)
        if node.right:
          stack.append(node.right)
      
    max_key = int(max(freq.values()))
    for key in freq.keys():
      if freq[key] == max_key:
        output.append(key)
    return output

## 783 Minimum Distance Between BST Nodes
Given the root of a Binary Search Tree (BST), return the minimum difference between the values of any two different nodes in the tree.
Input: root = [4,2,6,1,3]
Output: 1
Input: root = [1,0,48,null,null,12,49]
Output: 1

## Recursive
class Solution:
    def minDiffInBST(self, root: Optional[TreeNode]) -> int:
        
        self.ans = 1e9
        self.prev = -1e9
        def inorder(root):
            if root:
                if root.left:
                    inorder(root.left)
                self.ans = min(self.ans, root.val - self.prev )
                self.prev = root.val
                if root.right:
                    inorder(root.right)
        
        inorder(root)
        return self.ans
        
 ## Iterative
 class Solution:
    def minDiffInBST(self, root: Optional[TreeNode]) -> int:
        ans = 1e9
        prev = None
        stack = []
        node = root
        while stack or not node：
            if node:
              stack.append(node)
              node = node.left
            else:
              node = stack.pop()
              if prev and node.val - prev.val < ans:
                ans = node.val - prev.val
              prev = node
              node = node.right
         return ans
        




##235 Lowest Common Ancestor of a Binary Search Tree
Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants
(where we allow a node to be a descendant of itself).”

##Recursive
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
      def inorder(root, p,q):
        if root:
          if p.val > root.val and q.val > root.val:
            return inorder(root.right, p,q)
          elif p.val < root.val and q.val < root.val:
            return inorder(root.left,p,q)
          else:
            return root
      return inorder(root,p,q)
      
## Iterative
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
      while root：
        if p.val > root.val and q.val > root.val:
          root = root.right
        elif p.val < root.val and q.val < root.val:
          root = root.left
        else:
          return root
      

## 1214 Two Sum BSTs
Given the roots of two binary search trees, root1 and root2, 
return true if and only if there is a node in the first tree and a node in the second tree whose values sum up to a given integer target.


## Recursive
class Solution:
    def twoSumBSTs(self, root1: Optional[TreeNode], root2: Optional[TreeNode], target: int) -> bool:
        
        self.output1 = []
        self.output2 = []
        self.inorder(root1, self.output1)
        self.inorder(root2, self.output2)
        i = 0
        while i < len(self.output1):
            k = target - self.output1[i]
            if k in self.output2:
                return True
            i += 1
        return False
    def inorder(self, root, output):
        if root:
            if root.left:
                self.inorder(root.left, output)
            output.append(root.val)
            if root.right:
                self.inorder(root.right, output)
    
## Iterative
class Solution:
    def twoSumBSTs(self, root1: Optional[TreeNode], root2: Optional[TreeNode], target: int) -> bool:
        stack1 = [root1]
        stack2 = [root2]
        s = set()
        
        while stack1:
            node1 = stack1.pop()
            if node1:
                if node1.left:
                    stack1.append(node1.left)
                s.add(target - node1.val)
                if node1.right:
                    stack1.append(node1.right)
        #print(s)           
        while stack2:
            node2 = stack2.pop()
            if node2:
                if node2.left:
                    stack2.append(node2.left)
                if node2.val in s:
                    return True
                if node2.right:
                    stack2.append(node2.right)
        return False

## 230 Kth Smallest Element in a BST
Given the root of a binary search tree, and an integer k, return the kth (1-indexed) smallest element in the tree.
Input: root = [3,1,4,null,2], k = 1
Output: 1

## Recursive
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        self.ans = []
        self.inorder(root)
        print(self.ans)
        return self.ans[k-1]
    
    
    
    def inorder(self, root):
        if root:
            if root.left:
                self.inorder(root.left)
            self.ans.append(root.val)
            if root.right:
                self.inorder(root.right)
                
  ## Iterative
  class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        ans = []
        stack = []
        while stack or root:
            while root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            k -=1
            if k == 0:
                return root.val
            root = root.right
        





