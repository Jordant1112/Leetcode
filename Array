## 36 Valid Sudoku
Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:

Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
Note:

A Sudoku board (partially filled) could be valid but is not necessarily solvable.
Only the filled cells need to be validated according to the mentioned rules.

class Solution:
  def isValidSudoku(self, board: List[List[str]]) -> bool:
    N = len(board)
    row = [set() for x in range(N)]
    col = [set() for x in range(N)]
    boxes = [set() for x in range(N)]
    
    for r in range(N):
      for c in range(N):
        val = board[r][c]
        if val == '.':
          continue
        
        if val in row[r]:
          return False
        row[r].add(val)
        
        if val in col[r]:
          return False
        col[r].add(val)
        
        index = (c//3) + (r//3)*3
        if val in boxes[index]:
          return False
        boxes[index].add(val)
    return True


## 74 Search a 2D Matrix
Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:

Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.

Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
Output: true

Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
Output: false

class Solution:
  def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
    n = len(matrix)
    m = len(matrix[0])
    if n == 0:
      return False
      
    l = 0
    r = m*n -1
    while l <= r:
      mid = l + (r-l)//2
      if target == matrix[mid//m][mid % m]:
        return True
      else:
        if target < matrix[mid//m][mid % m]:
          r = mid - 1
        else:
          r = mid -1
    return False


## 15 3 Sum
Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.

Notice that the solution set must not contain duplicate triplets.

Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]

Input: nums = []
Output: []

class Solution:
  def threeSum(self, nums: List[int]) -> List[List[int]]:
    res = []
    nums.sort()
    for i in range(len(nums)):
      if nums[i] > 0:
        break
      if i == 0 or nums[i-1] != nums[i]:
        self.twoSum(nums, i, res)
    return res
  
  
  def twoSum(self, nums, i , res):
    lo = i+1
    hi = len(nums) -1
    while lo < hi:
      s = nums[i] + nums[lo] + nums[hi]
      if s < 0:
        lo += 1
      elif s < 0:
        hi -= 1
      else:
        res.append([nums[i], nums[lo], nums[hi]])
        lo += 1
        hi -= 1
        while lo < hi and nums[lo] == nums[lo -1]:
          lo += 1


## 346 Moving Average From Data Stream
Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.

Implement the MovingAverage class:

MovingAverage(int size) Initializes the object with the size of the window size.
double next(int val) Returns the moving average of the last size values of the stream.
 
Input
["MovingAverage", "next", "next", "next", "next"]
[[3], [1], [10], [3], [5]]
Output
[null, 1.0, 5.5, 4.66667, 6.0]

Explanation
MovingAverage movingAverage = new MovingAverage(3);
movingAverage.next(1); // return 1.0 = 1 / 1
movingAverage.next(10); // return 5.5 = (1 + 10) / 2
movingAverage.next(3); // return 4.66667 = (1 + 10 + 3) / 3
movingAverage.next(5); // return 6.0 = (10 + 3 + 5) / 3

class MovingAverage:

    def __init__(self, size: int):
        """
        Initialize your data structure here.
        """
        self.size = size
        self.res = []

    def next(self, val: int) -> float:
        size, res = self.size, self.res
        res.append(val)
        # calculate the sum of the moving window
        window_sum = sum(res[-size:])
        return window_sum / min(len(res), size)
    

 









