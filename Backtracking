## Combinations Template
# 77
def combination(self, n:int, k:int) -> List[List[int]]:
  if n == 0 or n < k:
    return []
  
  def backtrack(index, n, k, res):
    if len(res) == k:
      output.append(res[:])
    for i in range(index, n+1):
      res.append(i)
      backtrack(i+1, n, k, res)
      res.pop()
  output = []
  res = []
  backtrack(1,n,k,res)
  return output

# 17
Input: digits = "23"
Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]

def combination(self, digits: str) -> List[List[int]]:
  letters = {'2': ['a','b','c'], '3':['d','e','f'], '4':['g','h', 'i'], '5':['j','k', 'l'], \
                   '6': ['m','n','o'], '7':['p','q','r','s'], \
                  '8':['t','u','v'], '9': ['w','x','y','z']}
  
  if digits == '':
    return []
  
  def backtrack(index, output, res, digits):
    if index == len(digits):
      return output.append(''.join(res))
    for i in letters[digits[index]]:
      res.append(i)
      backtrack(index+1, output, res, digits)
      res.pop()
  
  output = []
  res = []
  backtrack(0,output,res,digits)
  return output


## Combination Sum
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]

def combinationsum(self, candidates, target):
  def backtrack(candidates, res, output, target):
    if target < 0:
      return []
    if target == 0:
      return output.append(res[:])
    for i in range(len(candidates)):
      res.append(candidates[i])
      backtrack(candidates[i:], res, output, target)
      res.pop()
  output = []
  res = []
  backtrack(candidates, res, output, target)
  return output
  
  
## Combination Sum II   ###Each number in candidates may only be used once in the combination
Input: candidates = [10,1,2,7,6,1,5], target = 8
Output: 
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
  
def backtrack(candidates, target, output, res, index):
  if target < 0:
    return []
  if target == 0:
    return output.append(res[:])
  for i in range(index, len(candidates)):
    if i > index and candidates[i] == candidates[i-1]:                           ### avoid duplicates, save time
      continue
    backtrack(candidates, target - candidates[i], output, res + [candidates[i]], i+1)
  
  
  output = []
  res = []
  backtrack(candidates, target, output, res, 0)
  return output

## Combination Sum III  216
######################################################################################################################################################################
Find all valid combinations of k numbers that sum up to n such that the following conditions are true:
Only numbers 1 through 9 are used.
Each number is used at most once.
Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.
Input: k = 3, n = 7
Output: [[1,2,4]]
Explanation:
1 + 2 + 4 = 7
There are no other valid combinations.
#####################################################################################################################################################################

def combinationSum3(self, k: int, n: int) -> List[List[int]]:
  if n == 0 or k > n:
    return []
  
  target = n
  def backtrack(n,k,index, output, res, target):
    if k < 0 or target < 0:
      return
    if target == 0 and k == 0:
      return output.append(res[:])
    
    for i in range(index, 10):                  ###only 1 to 9 are used
      res.append(i)
      backtrack(n,k - 1,i+1, output, res, target-i)
      res.pop()
      
   output = []
   res = []
   backtrack(n,k,1,output,res,target)
   return output




## Permutations Template
#46
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

def permute(self, nums: List[int]) -> List[List[int]]:
  if len(nums) == 0:
    return []
  
  def backtrack(index = 0):
    if index == len(nums):
      return output.append(res[:])
    for i in range(index, len(nums)):
      res.append(nums[index])
      backtrack(index+1)
      res.pop()
  output = []
  res = []
  backtrack()
  return output
  
## Permutations Template II
#47  
Input: nums = [1,1,2]
Output:
[[1,1,2],
 [1,2,1],
 [2,1,1]]
 
 def permute(self, nums: List[int]) -> List[List[int]]:
  if len(nums) == 0:
    return []
  
  def backtrack(output, res, nums, n):
    if len(res) == n:
      return output.append(res[:])
    for i in range(len(nums)):
      if i > 0 and nums[i] == nums[i-1]:
        continue
      backtrack(output, res+[nums[i]], nums[:i]+nums[i+1:],n)
  n = len(nums)
  output = []
  res = []
  backtrack(output, res, nums, n)
  return output
 

## Subsets 
## 78
Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
def subsets(self, nums: List[int]) -> List[List[int]]:
  if len(nums) == 0:
    return []
  
  def backtrack(output, res, nums, n):
    if len(res)<= n:
      return output.append(res[:])
    backtrack(output, res+ nums[i], nums[i+1:], n)
  
  output = []
  res = []
  n = len(nums)
  backtrack(output, res, nums, n)
  return output
  
## Subsets II 90
Input: nums = [1,2,2]
Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]

def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
  if len(nums) == 0:
    return []


##79 Word Search
Given an m x n grid of characters board and a string word, return true if word exists in the grid.
The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.
Example 1:
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
Output: true

###Note: sequentially adjacent cells, backtrack with a direction to find the letter in word
def exist(self, board: List[List[str]], word:str) ->bool:
  def backtrack(i,j,word, board):
    if len(word) == 0:
      return True
    if i < 0 or i >= len(board) or j < 0 or j >= len(board[i]):
      return False
    if board[i][j] == word[0]:
      board[i][j] = '#'
      if backtrack(i+1, j, word[1:], board) or backtrack(i-1, j, word[1:], board) or backtrack(i, j+1, word[1:], board) or backtrack(i, j-1, word[1:], board):
        return True
      board[i][j] == word[0]
    return False
  
  for i in range(len(board)):
    for j in range(len(board[i])):
      if backtrack(i,j,word, board):
        return True
   return False
  
  

## 254 factor combinations
Numbers can be regarded as the product of their factors.
Given an integer n, return all possible combinations of its factors. You may return the answer in any order.
Input: n = 12
Output: [[2,6],[3,4],[2,2,3]]
Input: n = 37
Output: []

def getfactors(self, n:int) -> List[List[int]]:
  if n <=1:
    return []
  
  def backtrack(output, res, n, index):
    if len(res) > 0:
      res.append(n)
      output.append(res[:])
      res.pop()
    
    for i in range(index, int(math.sqrt(n))+1):
      res.append(i)
      backtrack(output,res, n//i, i)
      res.pop()
   
  output = []
  res = []
  backtrack(output, res, n, 2)
  return output






