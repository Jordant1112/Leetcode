## Combinations Template
# 77
def combination(self, n:int, k:int) -> List[List[int]]:
  if n == 0 or n < k:
    return []
  
  def backtrack(index, n, k, res):
    if len(res) == k:
      output.append(res[:])
    for i in range(index, n+1):
      res.append(i)
      backtrack(i+1, n, k, res)
      res.pop()
  output = []
  res = []
  backtrack(1,n,k,res)
  return output

# 17
Input: digits = "23"
Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]

def combination(self, digits: str) -> List[List[int]]:
  letters = {'2': ['a','b','c'], '3':['d','e','f'], '4':['g','h', 'i'], '5':['j','k', 'l'], \
                   '6': ['m','n','o'], '7':['p','q','r','s'], \
                  '8':['t','u','v'], '9': ['w','x','y','z']}
  
  if digits == '':
    return []
  
  def backtrack(index, output, res, digits):
    if index == len(digits):
      return output.append(''.join(res))
    for i in letters[digits[index]]:
      res.append(i)
      backtrack(index+1, output, res, digits)
      res.pop()
  
  output = []
  res = []
  backtrack(0,output,res,digits)
  return output


## Combination Sum
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]

def combinationsum(self, candidates, target):
  def backtrack(candidates, res, output, target):
    if target < 0:
      return []
    if target == 0:
      return output.append(res[:])
    for i in range(len(candidates)):
      res.append(candidates[i])
      backtrack(candidates[i:], res, output, target)
      res.pop()
  output = []
  res = []
  backtrack(candidates, res, output, target)
  return output
  
  
## Combination Sum II   ###Each number in candidates may only be used once in the combination
Input: candidates = [10,1,2,7,6,1,5], target = 8
Output: 
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
  
def backtrack(candidates, target, output, res, index):
  if target < 0:
    return []
  if target == 0:
    return output.append(res[:])
  for i in range(index, len(candidates)):
    if i > index and candidates[i] == candidates[i-1]:                           ### avoid duplicates, save time
      continue
    backtrack(candidates, target - candidates[i], output, res + [candidates[i]], i+1)
  
  
  output = []
  res = []
  backtrack(candidates, target, output, res, 0)
  return output








## Permutations Template
#46
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

def permute(self, nums: List[int]) -> List[List[int]]:
  if len(nums) == 0:
    return []
  
  def backtrack(index = 0):
    if index == len(nums):
      return output.append(res[:])
    for i in range(index, len(nums)):
      res.append(nums[index])
      backtrack(index+1)
      res.pop()
  output = []
  res = []
  backtrack()
  return output
  
## Permutations Template II
#47  
Input: nums = [1,1,2]
Output:
[[1,1,2],
 [1,2,1],
 [2,1,1]]
 
 def permute(self, nums: List[int]) -> List[List[int]]:
  if len(nums) == 0:
    return []
  
  def backtrack(output, res, nums, n):
    if len(res) == n:
      return output.append(res[:])
    for i in range(len(nums)):
      if i > 0 and nums[i] == nums[i-1]:
        continue
      backtrack(output, res+[nums[i]], nums[:i]+nums[i+1:],n)
  n = len(nums)
  output = []
  res = []
  backtrack(output, res, nums, n)
  return output
 

## Subsets 
## 78
Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
def subsets(self, nums: List[int]) -> List[List[int]]:
  if len(nums) == 0:
    return []
  
  def backtrack(output, res, nums, n):
    if len(res)<= n:
      return output.append(res[:])
    backtrack(output, res+ nums[i], nums[i+1:], n)
  
  output = []
  res = []
  n = len(nums)
  backtrack(output, res, nums, n)
  return output
  
## Subsets II 90
Input: nums = [1,2,2]
Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]

def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
  


