### Kahn's Algorithm
Topological sorting helps solve the problem of pre-requisites. It provides a linear sorting based on the required ordering between vertices in directed acyclic graphs.
Limitation:
1). Topological sorting only works with graphs that are directed and acyclic
2). There is at least one vertex in the 'graph' with an 'in-degree' of 0. If all vertices in the 'graph' have non-zero 'in-degree', then all vertices need at least one vertex 
as a predecessor. In this case, no vertex can serve as the starting vertex. 




## 207 Course Schedule
There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. 
You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.
For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.
Return true if you can finish all courses. Otherwise, return false.


Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.

Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.



class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        g = collections.defaultdict(list)
        degree = {}
        for i in range(numCourses):
          degree[i] = 0
        for i,j in prerequisites:
          g[j].append(i)
          degree[i] += 1
        queue = []
        for i in range(numCourses):
          if degree[i] == 0:
            queue.append(i)
            
        course = []
        while queue:
          curr = queue.pop()
          del degree[curr]
          course.append(curr)
          for neighbor in g[curr]:
             degree[neighbor] -= 1
             if degree[neighbor] == 0:
                queue.append(neighbor)
       if len(course) == numCourses:
          return True
       else:
          return False
        
## 210 Course Schedule II
There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. 
You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.
For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.
Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, 
return an empty array.


Input: numCourses = 2, prerequisites = [[1,0]]
Output: [0,1]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].

Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: [0,2,1,3]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. 
Both courses 1 and 2 should be taken after you finished course 0.
So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].

class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        g = collections.defaultdict(list)
        degree = {}
        for i in range(numCourses):
            degree[i] = 0
        for i, j in prerequisites:
            g[j].append(i)
            degree[i] += 1
            
        queue = []
        for i in range(numCourses):
            if degree[i] == 0:
                queue.append(i)
        course = []
        while queue:
            curr = queue.pop()
            del degree[curr]
            course.append(curr)
            for n in g[curr]:
                degree[n] -=1
                if degree[n] == 0:
                    queue.append(n)
        
        if len(course) < numCourses:
            return []
        else:
            return course



### 1976 Number of Ways to Arrive at Destination

class Solution:
    def countPaths(self, n: int, roads: List[List[int]]) -> int:
        g = collections.defaultdict(list)
        for i,j,time in roads:
            g[i].append((j,time))
            g[j].append((i,time))
        times = [inf] * n
        times[0] = 0
        
        ways = [0]*n
        ways[0] = 1
        priorityqueue = [(0,0)]  
        while priorityqueue:
            old_t, i = heappop(priorityqueue)
            for j,time in g[i]:
                new_t = old_t + time
                if new_t < times[j]:
                    heappush(priorityqueue, (new_t, j))
                    times[j] = new_t
                    ways[j] = ways[i]
                elif new_t == times[j]:
                    ways[j] += ways[i]
        
        mod = 10**9 + 7
        return ways[-1] % mod
        
        

## Parallel Courses
You are given an integer n, which indicates that there are n courses labeled from 1 to n. 
You are also given an array relations where relations[i] = [prevCoursei, nextCoursei], representing a prerequisite relationship between 
course prevCoursei and course nextCoursei: course prevCoursei has to be taken before course nextCoursei.
In one semester, you can take any number of courses as long as you have taken all the prerequisites in the previous semester for the courses you are taking.
Return the minimum number of semesters needed to take all courses. If there is no way to take all the courses, return -1.

class Solution:
    def minimumSemesters(self, n: int, relations: List[List[int]]) -> int:
        g = collections.defaultdict(list)
        degree = {}
        
        for i in range(1, n+1):
            degree[i] = 0
        
        for i,j in relations:
            g[i].append(j)
            degree[j] += 1
        count = 0
        visited_count = 0
        course = []
        queue = []
        
        for i in range(1,n+1):
            if degree[i] == 0:
                queue.append(i)
        
        print(queue)
        while queue:
            count += 1
            next_queue = []
            for node in queue:
                visited_count += 1
                end_nodes = g[node]
                for end_node in end_nodes:
                    degree[end_node] -=1
                    if degree[end_node] == 0:
                        next_queue.append(end_node)
            queue = next_queue
        if visited_count == n:
            return count
        else:
            return -1



### 310 Minimum Height Trees
A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.
Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between 
the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. 
Among all possible rooted trees, those with minimum height (i.e. min(h))  are called minimum height trees (MHTs).
Return a list of all MHTs' root labels. You can return the answer in any order.
The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.

Input: n = 4, edges = [[1,0],[1,2],[1,3]]
Output: [1]
Explanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.

Input: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
Output: [3,4]

Input: n = 1, edges = []
Output: [0]


class Solution:
    def findMinHeightTrees(self, n:int, edges: List[List[int]]) -> List[int]:
        # Base cases
        if n <= 2:
            return [i for i in range(n)]
        
        ## Build the graph with the adjacency list
        neighbors = [set() for i in range(n)]
        for start, end in edges:
            neighbors[start].add(end)
            neighbors[end].add(start)
        
        ## Initialize the first layer of leaves
        leaves = []
        for i in range(n):
            if len(neighbors[i]) == 1:
                leaves.append(i)
        
        
        ## Trim the leaves until reaching the centroids
        remaining_nodes = n
        while remaining_nodes > 2:
            remaining_nodes -= len(leaves)
            new_leaves = []
            ## remove the current leaves along with the edges
            while leaves:
                leaf = leaves.pop()
                # the only neighbor left for the leaf node
                neighbor = neighbors[leaf].pop()
                # remove the only edge left
                neighbors[neighbor].remove(leaf)
                if len(neighbors[neighbor]) == 1:
                    new_leaves.append(neighbor)
            # prepare for the next round
            leaves = new_leaves
        # The remaining nodes are the centroids of the graph
        return leaves

## 802 Find Eventual Safe States
We start at some node in a directed graph, and every turn, we walk along a directed edge of the graph. 
If we reach a terminal node (that is, it has no outgoing directed edges), we stop.
We define a starting node to be safe if we must eventually walk to a terminal node. More specifically, there is a natural number k, 
so that we must have stopped at a terminal node in less than k steps for any choice of where to walk.
Return an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.
The directed graph has n nodes with labels from 0 to n - 1, where n is the length of graph. 
The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph, going from node i to node j.

Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]
Output: [2,4,5,6]

class Solution:
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
        N = len(graph)
        safe = []
        in_degree = collections.defaultdict(list)
        out_degree = {}
        queue = []
        for i in range(N):
            out_degree[i] = len(graph[i])
            if out_degree[i] == 0:
                queue.append(i)
            for j in graph[i]:
                in_degree[j].append(i)
        
        while queue:
            safe_node = queue.pop()
            safe.append(safe_node)
            for i in in_degree[safe_node]:
                out_degree[i] -=1
                if out_degree[i] == 0:
                    queue.append(i)
        return sorted(safe)
 
 
 
 
 
        
        
        
        
        
        
        
        











## 269 Alien Dictionary
There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you.
You are given a list of strings words from the alien language's dictionary, where the strings in words are sorted lexicographically by the rules of this new language.
Return a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new language's rules. 
If there is no solution, return "". If there are multiple solutions, return any of them.
A string s is lexicographically smaller than a string t if at the first letter where they differ, the letter in s comes before the letter in t in the alien language. 
If the first min(s.length, t.length) letters are the same, then s is smaller if and only if s.length < t.length.











