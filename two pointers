## 202 Happy Number (龟兔赛跑问题)
Write an algorithm to determine if a number n is happy.

A happy number is a number defined by the following process:

Starting with any positive integer, replace the number by the sum of the squares of its digits.
Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.
Those numbers for which this process ends in 1 are happy.
Return true if n is a happy number, and false if not.

Input: n = 19
Output: true
Explanation:
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1


class Solution:
    def isHappy(self, n: int) -> bool:
        def get_next(number):
            total_sum = 0
            while number > 0:
                number, digit = divmod(number, 10)
                total_sum += digit **2
            return total_sum
        
        slow = n
        fast = get_next(n)
        while fast != 1 and slow != fast:
            slow = get_next(slow)
            fast = get_next(get_next(fast))
        return fast == 1
        
### 345. Reverse Vowels of a String  
Given a string s, reverse only all the vowels in the string and return it.

The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both cases.
 Input: s = "hello"
Output: "holle"
class Solution(object):
    def reverseVowels(self, s):
        vowels = set(list("aeiouAEIOU"))
        s = list(s)
        ptr_1, ptr_2 = 0, len(s) - 1
        while ptr_1 < ptr_2:
            if s[ptr_1] in vowels and s[ptr_2] in vowels:
                s[ptr_1], s[ptr_2] = s[ptr_2], s[ptr_1]
                ptr_1 += 1
                ptr_2 -= 1
            if s[ptr_1] not in vowels:
                ptr_1 += 1
            if s[ptr_2] not in vowels:
                ptr_2 -= 1
        return ''.join(s)

## 680. Valid Palindrome II
Given a string s, return true if the s can be palindrome after deleting at most one character from it.
Input: s = "aba"
Output: true

Input: s = "abca"
Output: true
Explanation: You could delete the character 'c'.

class Solution:
    def validPalindrome(self, s: str) -> bool:
        left = 0
        right = len(s)-1
        while left < right:
            if s[left] != s[right]:
                solution_1 = s[left:right]
                solution_2 = s[left+1: right+1]
                return solution_1 == solution_1[::-1] or solution_2 == solution_2[::-1]
            left +=1
            right -=1
        return True


## 392 Is Subsequence
Given two strings s and t, return true if s is a subsequence of t, or false otherwise.

A subsequence of a string is a new string that is formed from the original string by deleting some 
(can be none) of the characters without disturbing the relative positions of the remaining characters. 
(i.e., "ace" is a subsequence of "abcde" while "aec" is not).

Input: s = "abc", t = "ahbgdc"
Output: true

Input: s = "axc", t = "ahbgdc"
Output: false

class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        l_1 = len(s)
        l_2 = len(t)
        pointer1 = 0
        pointer2 = 0
        while pointer1 < l_1 and pointer2 < l_2:
            if s[pointer1] == t[pointer2]:
                pointer1 += 1
                pointer2 += 1
            else:
                pointer2 += 1
        return pointer1 == l_1
        



## 75 Sort Colors
Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, 
with the colors in the order red, white, and blue.
We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.
You must solve this problem without using the library's sort function.

class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        left = 0
        right = len(nums)-1
        curr = 0
        
        while curr <= right:
            if nums[curr] ==0:
                nums[curr], nums[left] = nums[left] , nums[curr]
                left += 1
                curr += 1
            elif nums[curr] == 2:
                nums[curr], nums[right] = nums[right], nums[curr]
                right -= 1
            else:
                curr +=1 
        return nums


##246 Strobogrammatic number
Given a string num which represents an integer, return true if num is a strobogrammatic number.
A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).


Input: num = "69"
Output: true

Input: num = "88"
Output: true

Input: num = "962"
Output: false
## Approach 1
class Solution:
    def isStrobogrammatic(self, num: str) -> bool:
        rotated_string = []
        for char in reversed(num):
            if char in {'0','1','8'}:
                rotated_string.append(char)
            elif char =='6':
                rotated_string.append('9')
            elif char =='9':
                rotated_string.append('6')
            else：
                return False
        s = ''.join(rotated_string)
        return s == num
## Approach 2
Hashmap
class Solution:
    def isStrobogrammatic(self, num: str) -> bool:
        d = {
          '1': '1',
          '2': '*',
          '3': '*',
          '4': '*',
          '5': '*',
          '6': '9',
          '7': '*',
          '8': '8',
          '9': '6'
        }
        s = ''
        for char in num:
            s += d[char]
        return s[::-1] == num


## 844 Backspace String Compare
Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.

Note that after backspacing an empty text, the text will continue empty.

Input: s = "ab#c", t = "ad#c"
Output: true
Explanation: Both s and t become "ac".

Input: s = "a##c", t = "#a#c"
Output: true
Explanation: Both s and t become "c".

class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        def build(s):
            ans = []
            for c in s:
                if c != '#':
                    ans.append(c)
                elif ans:
                    ans.pop()
            return ''.join(ans)
         return build(s) == build(t)
### You can also use two pointer to go through the string s and t


###1570. Dot Product of Two Sparse Vectors
Given two sparse vectors, compute their dot product.

Implement class SparseVector:

SparseVector(nums) Initializes the object with the vector nums
dotProduct(vec) Compute the dot product between the instance of SparseVector and vec
A sparse vector is a vector that has mostly zero values, you should store the sparse vector efficiently and compute the dot product between two SparseVector.

Follow up: What if only one of the vectors is sparse?

Input: nums1 = [1,0,0,2,3], nums2 = [0,3,0,4,0]
Output: 8
Explanation: v1 = SparseVector(nums1) , v2 = SparseVector(nums2)
v1.dotProduct(v2) = 1*0 + 0*3 + 0*0 + 2*4 + 3*0 = 8

class SparseVector:
    def __init__(self, nums: List[int]):
        self.nonzeros = {}
        for i, n in enumerate(nums):
            if n != 0:
                self.nonzeros[i] = n
    def dotProduct(self, vec: 'SparseVector') -> int:
        res = 0
        for i, n in self.nonzeros.items():
            if i in vec.nonzeros:
                res += vec.nonzeros[i] * n
        return res















