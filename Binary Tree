## 110 Balanced Binary Tree
Given a binary tree, determine if it is height-balanced.
For this problem, a height-balanced binary tree is defined as:
a binary tree in which the left and right subtrees of every node differ in height by no more than 1.

Input: root = [3,9,20,null,null,15,7]
Output: true

class Solution:
  def isBalanced(self, root: Optional[TreeNode]) -> bool:
    if not root:
      return True
    if abs(self.height(root.left) - self.height(root.right)) > 1:
      return False
    else:
      return self.isBalanced(root.left) and self.isBalanced(root.right)
  
  
  def height(self, root) -> int:
    if not root:
      return -1
    return 1 + max(self.height(root.left), self.height(root.right))


## 1302 Deepest Leaves Sum
Given the root of a binary tree, return the sum of values of its deepest leaves.

class Solution:
    def deepestLeavesSum(self, root: Optional[TreeNode]) -> int:
        self.res = []
        self.depth = 0
        self.inorder(root,0)
        print(self.res)
        return sum(self.res[-1])
    
    def inorder(self, root, depth):
        if len(self.res) < depth:
            self.res.append([])
            
        if root:
            self.inorder(root.left, depth+1)   
            self.inorder(root.right, depth +1)
            self.res[depth].append(root.val)
            
## 654. Maximum Binary Tree
You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm:

Create a root node whose value is the maximum value in nums.
Recursively build the left subtree on the subarray prefix to the left of the maximum value.
Recursively build the right subtree on the subarray suffix to the right of the maximum value.
Return the maximum binary tree built from nums.

class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:
        if len(nums) == 0:
            return 
        m = max(nums)
        index = nums.index(m)
        print(index)
        root = TreeNode(max(nums))
        
        root.left = self.constructMaximumBinaryTree(nums[:index])
        root.right = self.constructMaximumBinaryTree(nums[index+1:])
        
        return root


513. Find Bottom Left Tree Value
Given the root of a binary tree, return the leftmost value in the last row of the tree.
class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        self.res = []
        self.inorder(root,0)
        return self.res[-1][0]
    
    
    def inorder(self, root, depth):
        if len(self.res) < depth:
            self.res.append([])
        if root:
            self.inorder(root.left, depth + 1)
            self.res[depth].append(root.val)
            self.inorder(root.right, depth + 1)
            
114. Flatten Binary Tree to Linked List

Given the root of a binary tree, flatten the tree into a "linked list":
The "linked list" should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.
The "linked list" should be in the same order as a pre-order traversal of the binary tree.
            
Input: root = [1,2,5,3,4,null,6]
Output: [1,null,2,null,3,null,4,null,5,null,6]           
            
Input: root = []
Output: []


class Solution:
  def flatten(self, root: Optional[TreeNode]) -> Node:
    self.flat_tree(root)
  
  def flat_tree(self, root):
    if not root:
      return None
    if not root.right and not root.left:
      return root
    lefttail = self.flat_tree(root.left)
    righttail = self.flat_tree(root.right)
    
    if lefttail:
      lefttail.right = root.right
      root.right = root.left
      root.left = None
   return righttail if righttail else lefttail
   


129. Sum Root to Leaf Numbers
You are given the root of a binary tree containing digits from 0 to 9 only.
Each root-to-leaf path in the tree represents a number.
For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.
Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer.
A leaf node is a node with no children.

Input: root = [1,2,3]
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.

class Solution:
  def sumNumbers(self, root: Optional[TreeNode]) -> int:
    self.value = 0
    self.helper(root, self.value)
    return self.value
    
  def helper(self, root, v):
    if root:
      if not root.right and not root.left:
        v = v * 10 + root.val
        self.value += v
      self.helper(root.left, v*10 + root.val)
      self.helper(root.right, v*10 + root.val)
      

## 103 Binary Tree Zigzag Level Order traversal
Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. 
(i.e., from left to right, then right to left for the next level and alternate between).

Input: root = [3,9,20,null,null,15,7]
Output: [[3],[20,9],[15,7]]


## DFS
class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        self.res = []
        self.dfs(root, 0)
        return self.res
    
    def dfs(self, root,i):
        if not root:
            return []
        elif len(self.res) <= i:
            self.res.append([root.val])
        elif i % 2 ==0:
            self.res[i].extend([root.val])
        else:
            self.res[i].insert(0, root.val)
        self.dfs(root.left, i+1)
        self.dfs(root.right, i+1)
        

## BFS  
class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        queue = collections.deque([root])
        res = []
        even_level = False
        while queue:
            n = len(queue)
            level = []
            for i in range(n):
                if even_level:
                    node = queue.pop()
                    if node.right:
                        queue.appendleft(node.right)
                    if node.left:
                        queue.appendleft(node.left)
                else:
                    node = queue.popleft()
                    if node.left:
                        queue.append(node.left)
                    if node.right:
                        queue.append(node.right)
                level.append(node.val) 
            res.append(level)
            even_level = not even_level
        return res
    
## 563 Binary Tree Tilt
Given the root of a binary tree, return the sum of every tree node's tilt.
The tilt of a tree node is the absolute difference between the sum of all left subtree node values and all right subtree node values. 
If a node does not have a left child, then the sum of the left subtree node values is treated as 0. The rule is similar if there the node does not have a right child.

class Solution:
    def findTilt(self, root: Optional[TreeNode]) -> int:
        self.total_tilt = 0
        self.dfs(root)
        return self.total_tilt
    def dfs(self, root):
        if not root:
            return 0
        left_sum = self.dfs(root.left)
        right_sum = self.dfs(root.right)
        tilt = abs(left_sum - right_sum)
        self.total_tilt += tilt
        return left_sum+right_sum + root.val









