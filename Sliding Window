## 1763. Longest Nice Substring
A string s is nice if, for every letter of the alphabet that s contains, it appears both in uppercase and lowercase. For example, 
"abABB" is nice because 'A' and 'a' appear, and 'B' and 'b' appear. However, "abA" is not because 'b' appears, but 'B' does not.
Given a string s, return the longest substring of s that is nice. If there are multiple, return the substring of the earliest occurrence. 
If there are none, return an empty string.

Input: s = "YazaAay"
Output: "aAa"
Explanation: "aAa" is a nice string because 'A/a' is the only letter of the alphabet in s, and both 'A' and 'a' appear.
"aAa" is the longest nice substring.

Input: s = "Bb"
Output: "Bb"
Explanation: "Bb" is a nice string because both 'B' and 'b' appear. The whole string is a substring.

Input: s = "c"
Output: ""
Explanation: There are no nice substrings.

Input: s = "dDzeE"
Output: "dD"
Explanation: Both "dD" and "eE" are the longest nice substrings.
As there are multiple longest nice substrings, return "dD" since it occurs earlier.


class Solution:
  def longestNiceSubstring(self, s):
    if len(s) < 2:
      return ''
    char = set(s)
    for i in range(len(s)):
      if not (s[i].upper in char and s[i].lower in char):
        s1 = self.longestNiceSubstring(s[:i])
        s2 = self.longestNiceSubstring(s[i+1:])
        return s2 if len(s2) > len(s1) else s1
    return s


## 1876 Substrings of Size Three with Distinct Characters

class Solution:
  def countGoodSubstrings(self, s: str) -> int:
    count = 0
    for i in range(len(s)-2):
      if len(set(s[i:i+3])) == 3:
        count += 1
    return count

## 643 Maximum Average Subarray I
You are given an integer array nums consisting of n elements, and an integer k.
Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. 
Any answer with a calculation error less than 10-5 will be accepted.

Input: nums = [1,12,-5,-6,50,3], k = 4
Output: 12.75000
Explanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75
Input: nums = [5], k = 1
Output: 5.00000


class Solution:
  def findMaxAverage(self, nums: List[int], k:int) -> float:
    s = sum(nums[:k])
    maximum = s
    for i in range(1, len(nums)-k+1):
      s -= nums[i-1]
      s += nums[i+k-1]
      maximum = max(maximum, s)
    return maximum/k


#### 219. Contains Duplicate II
Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.
Input: nums = [1,2,3,1], k = 3
Output: true

Input: nums = [1,2,3,1,2,3], k = 2
Output: false


# Approach 1, Dictionary
class Solution:
  def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool: 
      d = {}
      for i, v in enumerate(nums):
        if v in d and i - d[v] <= k:
          return True
        d[v] = i
      return False

## Approach 2, Sliding Windows
class Solution:
  def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool: 
      windows = set()
      for i in range(0 , len(nums)):
        if len(windows) >= k+1:
          window.remove(nums[i-k-1])
        if nums[i] in windows:
          return True
        windows.add(nums[i])
      return False

## 1176 Diet Plan Performance

A dieter consumes calories[i] calories on the i-th day. 
Given an integer k, for every consecutive sequence of k days (calories[i], calories[i+1], ..., calories[i+k-1] for all 0 <= i <= n-k), they look at T, 
the total calories consumed during that sequence of k days (calories[i] + calories[i+1] + ... + calories[i+k-1]):
If T < lower, they performed poorly on their diet and lose 1 point; 
If T > upper, they performed well on their diet and gain 1 point;
Otherwise, they performed normally and there is no change in points.
Initially, the dieter has zero points. Return the total number of points the dieter has after dieting for calories.length days.
Note that the total points can be negative.

Input: calories = [1,2,3,4,5], k = 1, lower = 3, upper = 3
Output: 0
Explanation: Since k = 1, we consider each element of the array separately and compare it to lower and upper.
calories[0] and calories[1] are less than lower so 2 points are lost.
calories[3] and calories[4] are greater than upper so 2 points are gained.

Input: calories = [3,2], k = 2, lower = 0, upper = 1
Output: 1
Explanation: Since k = 2, we consider subarrays of length 2.
calories[0] + calories[1] > upper so 1 point is gained.

class Solution:
  def dietPlanPerformance(self, calories: List[int], k: int, lower:int, upper: int) -> int:
    ans = 0
    T = sum(calories[0:k])
    if T > upper: ans += 1
    if T < lower: ans -= 1
    for i in range(1, len(calories)-k+1):
      T -= calories[i-1]
      T += calories[i+k-1]
      if T > upper: ans += 1
      elif T < lower: ans -=1
      else:
        ans += 0
    return ans


## 209 Minimum Size Subarray Sum
Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, ..., numsr-1, numsr] 
of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead.

Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.
 

Input: target = 4, nums = [1,4,4]
Output: 1

Input: target = 11, nums = [1,1,1,1,1,1,1,1]
Output: 0

class Solution:
  def minSubArrayLen(self, target: int, nums: List[int]) -> int:
    left = 0
    right = 0
    total = 0
    ans = len(nums) + 1
    while right < len(nums):
      total += nums[right]
      while total >= target:
        ans = min(ans, right - left + 1)
        total -= nums[left]
        left += 1
      right += 1
    return ans if ans <= len(nums) else 0




## 159 Longest Substring with at Most 2 distinct Characters:

Given a string s, return the length of the longest substring that contains at most two distinct characters.
Input: s = "eceba"
Output: 3
Explanation: The substring is "ece" which its length is 3.

Input: s = "ccaabbb"
Output: 5
Explanation: The substring is "aabbb" which its length is 5.


class Solution:
  def lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:
    d = {}
    n = len(s)
    if n < 3:
      return n
    left = 0
    right = 0
    ans = 2   ## minimum length for 2 distinct chars
    
    while right < n:
      d[s[right]] = right
      right += 1
      
      if len(d) == 3:
        index = min(d.values())
        del d[s[index]]
        left = index + 1
      ans = max(ans, right - left)
    return ans
























