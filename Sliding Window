## 1763. Longest Nice Substring
A string s is nice if, for every letter of the alphabet that s contains, it appears both in uppercase and lowercase. For example, 
"abABB" is nice because 'A' and 'a' appear, and 'B' and 'b' appear. However, "abA" is not because 'b' appears, but 'B' does not.
Given a string s, return the longest substring of s that is nice. If there are multiple, return the substring of the earliest occurrence. 
If there are none, return an empty string.

Input: s = "YazaAay"
Output: "aAa"
Explanation: "aAa" is a nice string because 'A/a' is the only letter of the alphabet in s, and both 'A' and 'a' appear.
"aAa" is the longest nice substring.

Input: s = "Bb"
Output: "Bb"
Explanation: "Bb" is a nice string because both 'B' and 'b' appear. The whole string is a substring.

Input: s = "c"
Output: ""
Explanation: There are no nice substrings.

Input: s = "dDzeE"
Output: "dD"
Explanation: Both "dD" and "eE" are the longest nice substrings.
As there are multiple longest nice substrings, return "dD" since it occurs earlier.


class Solution:
  def longestNiceSubstring(self, s):
    if len(s) < 2:
      return ''
    char = set(s)
    for i in range(len(s)):
      if not (s[i].upper in char and s[i].lower in char):
        s1 = self.longestNiceSubstring(s[:i])
        s2 = self.longestNiceSubstring(s[i+1:])
        return s2 if len(s2) > len(s1) else s1
    return s


## 1876 Substrings of Size Three with Distinct Characters

class Solution:
  def countGoodSubstrings(self, s: str) -> int:
    count = 0
    for i in range(len(s)-2):
      if len(set(s[i:i+3])) == 3:
        count += 1
    return count

## 643 Maximum Average Subarray I
You are given an integer array nums consisting of n elements, and an integer k.
Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. 
Any answer with a calculation error less than 10-5 will be accepted.

Input: nums = [1,12,-5,-6,50,3], k = 4
Output: 12.75000
Explanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75
Input: nums = [5], k = 1
Output: 5.00000


class Solution:
  def findMaxAverage(self, nums: List[int], k:int) -> float:
    s = sum(nums[:k])
    maximum = s
    for i in range(1, len(nums)-k+1):
      s -= nums[i-1]
      s += nums[i+k-1]
      maximum = max(maximum, s)
    return maximum/k


#### 219. Contains Duplicate II
Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.
Input: nums = [1,2,3,1], k = 3
Output: true

Input: nums = [1,2,3,1,2,3], k = 2
Output: false


# Approach 1, Dictionary
class Solution:
  def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool: 
      d = {}
      for i, v in enumerate(nums):
        if v in d and i - d[v] <= k:
          return True
        d[v] = i
      return False

## Approach 2, Sliding Windows
class Solution:
  def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool: 
      windows = set()
      for i in range(0 , len(nums)):
        if len(windows) >= k+1:
          window.remove(nums[i-k-1])
        if nums[i] in windows:
          return True
        windows.add(nums[i])
      return False

## 1176 Diet Plan Performance

A dieter consumes calories[i] calories on the i-th day. 
Given an integer k, for every consecutive sequence of k days (calories[i], calories[i+1], ..., calories[i+k-1] for all 0 <= i <= n-k), they look at T, 
the total calories consumed during that sequence of k days (calories[i] + calories[i+1] + ... + calories[i+k-1]):
If T < lower, they performed poorly on their diet and lose 1 point; 
If T > upper, they performed well on their diet and gain 1 point;
Otherwise, they performed normally and there is no change in points.
Initially, the dieter has zero points. Return the total number of points the dieter has after dieting for calories.length days.
Note that the total points can be negative.

Input: calories = [1,2,3,4,5], k = 1, lower = 3, upper = 3
Output: 0
Explanation: Since k = 1, we consider each element of the array separately and compare it to lower and upper.
calories[0] and calories[1] are less than lower so 2 points are lost.
calories[3] and calories[4] are greater than upper so 2 points are gained.

Input: calories = [3,2], k = 2, lower = 0, upper = 1
Output: 1
Explanation: Since k = 2, we consider subarrays of length 2.
calories[0] + calories[1] > upper so 1 point is gained.

class Solution:
  def dietPlanPerformance(self, calories: List[int], k: int, lower:int, upper: int) -> int:
    ans = 0
    T = sum(calories[0:k])
    if T > upper: ans += 1
    if T < lower: ans -= 1
    for i in range(1, len(calories)-k+1):
      T -= calories[i-1]
      T += calories[i+k-1]
      if T > upper: ans += 1
      elif T < lower: ans -=1
      else:
        ans += 0
    return ans


## 209 Minimum Size Subarray Sum
Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, ..., numsr-1, numsr] 
of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead.

Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.
 

Input: target = 4, nums = [1,4,4]
Output: 1

Input: target = 11, nums = [1,1,1,1,1,1,1,1]
Output: 0

class Solution:
  def minSubArrayLen(self, target: int, nums: List[int]) -> int:
    left = 0
    right = 0
    total = 0
    ans = len(nums) + 1
    while right < len(nums):
      total += nums[right]
      while total >= target:
        ans = min(ans, right - left + 1)
        total -= nums[left]
        left += 1
      right += 1
    return ans if ans <= len(nums) else 0




## 159 Longest Substring with at Most 2 distinct Characters:

Given a string s, return the length of the longest substring that contains at most two distinct characters.
Input: s = "eceba"
Output: 3
Explanation: The substring is "ece" which its length is 3.

Input: s = "ccaabbb"
Output: 5
Explanation: The substring is "aabbb" which its length is 5.


class Solution:
  def lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:
    d = {}
    n = len(s)
    if n < 3:
      return n
    left = 0
    right = 0
    ans = 2   ## minimum length for 2 distinct chars
    
    while right < n:
      d[s[right]] = right
      right += 1
      
      if len(d) == 3:
        index = min(d.values())
        del d[s[index]]
        left = index + 1
      ans = max(ans, right - left)
    return ans



## 1852. Distinct Numbers in Each Subarray
Given an integer array nums and an integer k, you are asked to construct the array ans of size n-k+1 
where ans[i] is the number of distinct numbers in the subarray nums[i:i+k-1] = [nums[i], nums[i+1], ..., nums[i+k-1]].

Input: nums = [1,2,3,2,2,1,3], k = 3
Output: [3,2,2,2,3]
Explanation: The number of distinct elements in each subarray goes as follows:
- nums[0:2] = [1,2,3] so ans[0] = 3
- nums[1:3] = [2,3,2] so ans[1] = 2
- nums[2:4] = [3,2,2] so ans[2] = 2
- nums[3:5] = [2,2,1] so ans[3] = 2
- nums[4:6] = [2,1,3] so ans[4] = 3

Input: nums = [1,1,1,1,2,3,4], k = 4
Output: [1,2,3,4]
Explanation: The number of distinct elements in each subarray goes as follows:
- nums[0:3] = [1,1,1,1] so ans[0] = 1
- nums[1:4] = [1,1,1,2] so ans[1] = 2
- nums[2:5] = [1,1,2,3] so ans[2] = 3
- nums[3:6] = [1,2,3,4] so ans[3] = 4


class Solution:
  def distinctNumbers(self, nums: List[int], k:int) -> List[int]:
    c = collections.Counter(nums[:k])
    ## c can also = {} and then a for loop through nums[:k]
    res = []
    res.append(len(c))
    for i in range(k, len(nums)):
      if nums[i] in c:
        c[nums[i]] += 1
      else:
        c[nums[i]] = 1
      c[nums[i-k]] -= 1
      if c[nums[i-k]] == 0:
        c.pop(nums[i-k])
      res.append(len(c))
    return res

class Solution:
  def distinctNumbers(self, nums:List[int], k:int) -> List[int]:
    c = collections.Counter(nums[:k])
    cur = len(c)
    res = [cur]
    
    for i in range(k, len(nums)):
      c[nums[i-k]] -= 1
      if c[nums[i-k]] == 0:
        cur -= 1
      if c[nums[i]] == 0:
        cur += 1
      c[nums[i]] += 1
      res.append(cur)
    return res
      
## 1100 Find K-length Substrings With No Repeated Characters
Given a string s and an integer k, return the number of substrings in s of length k with no repeated characters.

Input: s = "havefunonleetcode", k = 5
Output: 6
Explanation: There are 6 substrings they are: 'havef','avefu','vefun','efuno','etcod','tcode'.

Input: s = "home", k = 5
Output: 0
Explanation: Notice k can be larger than the length of s. In this case, it is not possible to find any substring.

## Approach 1
class Solution:
  def numKLenSubstrNoRepeats(self, s: str, k: int) -> int:
    if k > len(s):
      return 0
    c = collections.Counter(s[:k])
    ans = 0
    if max(c.values()) == 1 and len(c) == k:
      ans += 1
    for i in range(k, len(s)):
      if s[i] not in c:
        c[s[i]] = 1
      else:
        c[s[i]] += 1
      c[s[i-k]] -= 1
      if c[s[i-k]] == 0:
        c.pop(s[i-k])
      if len(c) == k and all(value == 1 for value in c.values()):
        ans += 1
      else:
        continue
    return ans

Approach 2
class Solution:
    def numKLenSubstrNoRepeats(self, s: str, k: int) -> int:
        if len(s) < k:
            return 0
        
        self.points = 0
        currString = s[:k]
        self.checkDup(currString)
        
        for i in range(len(s) - k):
            currString = s[i+1:i+k+1]
            self.checkDup(currString)
        
        return self.points 
    
    def checkDup(self, currString):
        if len(currString) == len(set(currString)):
            self.points += 1

## 1343 Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold
Given an array of integers arr and two integers k and threshold.
Return the number of sub-arrays of size k and average greater than or equal to threshold.

Input: arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4
Output: 3
Explanation: Sub-arrays [2,5,5],[5,5,5] and [5,5,8] have averages 4, 5 and 6 respectively. All other sub-arrays of size 3 have averages less than 4 (the threshold).
 

Input: arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5
Output: 6
Explanation: The first 6 sub-arrays of size 3 have averages greater than 5. Note that averages are not integers.

class Solution:
  def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:
    sub_arr = sum(arr[:k])
    ans = 0
    l = k * threshold
    if sub_arr >= l:
      ans += 1
    for i in range(k, len(arr)):
      sub_arr -= arr[i-k]
      sub_arr += arr[i]
      if sub_arr >= l:
        ans += 1
    return ans



## 1358 Number of Substrings Containing All Three Characters:
Given a string s consisting only of characters a, b and c.
Return the number of substrings containing at least one occurrence of all these characters a, b and c.

Input: s = "abcabc"
Output: 10
Explanation: The substrings containing at least one 
occurrence of the characters a, b and c are "abc", "abca", "abcab", "abcabc", "bca", "bcab", "bcabc", "cab", "cabc" and "abc" (again). 

Input: s = "aaacb"
Output: 3
Explanation: The substrings containing at least one occurrence of the characters a, b and c are "aaacb", "aacb" and "acb". 

#################################################
Maintain a window which contains at least each character of a, b and c.
Once we found a window, rest part of that window will be a valid count.
So we can add len(s) - i on it.
################################################
class Solution:
  j = 0
  result = 0
  d = collections.Counter()
  for i, char in enumerate(s):
    d[char] += 1
    while len(d) == 3:
      result += len(s) - i
      d[s[j]] -= 1
      if d[s[j]] == 0:
        del d[s[j]]
      j += 1
  return result

## 1004. Max Consecutive Ones III
Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.

Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
Output: 6
Explanation: [1,1,1,0,0,1,1,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.

Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
Output: 10
Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
## My approach
class Solution:
  def longestOnes(self, nums: List[int], k:int) -> int:
    max_l = 0
    left = 0
    right = 0
    count_zero = 0
    while right < len(nums):
      if nums[right] == 0:
        count_zero += 1
      if count_zero <= k:
        max_l = max(max_l, right - left + 1)
      right += 1
      while count_zero > k:
        if nums[left] == 0:
          count_zero -= 1
        left += 1
   return max_l
  
#### Approach 2    
class Solution:
  left = right = 0
  for right in range(len(nums)):
    if nums[right] == 0:
      k -= 1
    if k < 0:
      if nums[left] == 0:
        k += 1
      left += 1
  return right - left + 1
    
    













 







