## 1763. Longest Nice Substring
A string s is nice if, for every letter of the alphabet that s contains, it appears both in uppercase and lowercase. For example, 
"abABB" is nice because 'A' and 'a' appear, and 'B' and 'b' appear. However, "abA" is not because 'b' appears, but 'B' does not.
Given a string s, return the longest substring of s that is nice. If there are multiple, return the substring of the earliest occurrence. 
If there are none, return an empty string.

Input: s = "YazaAay"
Output: "aAa"
Explanation: "aAa" is a nice string because 'A/a' is the only letter of the alphabet in s, and both 'A' and 'a' appear.
"aAa" is the longest nice substring.

Input: s = "Bb"
Output: "Bb"
Explanation: "Bb" is a nice string because both 'B' and 'b' appear. The whole string is a substring.

Input: s = "c"
Output: ""
Explanation: There are no nice substrings.

Input: s = "dDzeE"
Output: "dD"
Explanation: Both "dD" and "eE" are the longest nice substrings.
As there are multiple longest nice substrings, return "dD" since it occurs earlier.


class Solution:
  def longestNiceSubstring(self, s):
    if len(s) < 2:
      return ''
    char = set(s)
    for i in range(len(s)):
      if not (s[i].upper in char and s[i].lower in char):
        s1 = self.longestNiceSubstring(s[:i])
        s2 = self.longestNiceSubstring(s[i+1:])
        return s2 if len(s2) > len(s1) else s1
    return s


## 1876 Substrings of Size Three with Distinct Characters

class Solution:
  def countGoodSubstrings(self, s: str) -> int:
    count = 0
    for i in range(len(s)-2):
      if len(set(s[i:i+3])) == 3:
        count += 1
    return count

## 643 Maximum Average Subarray I
You are given an integer array nums consisting of n elements, and an integer k.
Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. 
Any answer with a calculation error less than 10-5 will be accepted.

Input: nums = [1,12,-5,-6,50,3], k = 4
Output: 12.75000
Explanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75
Input: nums = [5], k = 1
Output: 5.00000


class Solution:
  def findMaxAverage(self, nums: List[int], k:int) -> float:
    s = sum(nums[:k])
    maximum = s
    for i in range(1, len(nums)-k+1):
      s -= nums[i-1]
      s += nums[i+k-1]
      maximum = max(maximum, s)
    return maximum/k


#### 219. Contains Duplicate II
Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.
Input: nums = [1,2,3,1], k = 3
Output: true

Input: nums = [1,2,3,1,2,3], k = 2
Output: false


# Approach 1, Dictionary
class Solution:
  def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool: 
      d = {}
      for i, v in enumerate(nums):
        if v in d and i - d[v] <= k:
          return True
        d[v] = i
      return False

## Approach 2, Sliding Windows
class Solution:
  def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool: 
      windows = set()
      for i in range(0 , len(nums)):
        if len(windows) >= k+1:
          window.remove(nums[i-k-1])
        if nums[i] in windows:
          return True
        windows.add(nums[i])
      return False












