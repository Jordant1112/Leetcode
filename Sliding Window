## 1763. Longest Nice Substring
A string s is nice if, for every letter of the alphabet that s contains, it appears both in uppercase and lowercase. For example, 
"abABB" is nice because 'A' and 'a' appear, and 'B' and 'b' appear. However, "abA" is not because 'b' appears, but 'B' does not.
Given a string s, return the longest substring of s that is nice. If there are multiple, return the substring of the earliest occurrence. 
If there are none, return an empty string.

Input: s = "YazaAay"
Output: "aAa"
Explanation: "aAa" is a nice string because 'A/a' is the only letter of the alphabet in s, and both 'A' and 'a' appear.
"aAa" is the longest nice substring.

Input: s = "Bb"
Output: "Bb"
Explanation: "Bb" is a nice string because both 'B' and 'b' appear. The whole string is a substring.

Input: s = "c"
Output: ""
Explanation: There are no nice substrings.

Input: s = "dDzeE"
Output: "dD"
Explanation: Both "dD" and "eE" are the longest nice substrings.
As there are multiple longest nice substrings, return "dD" since it occurs earlier.


class Solution:
  def longestNiceSubstring(self, s):
    if len(s) < 2:
      return ''
    char = set(s)
    for i in range(len(s)):
      if not (s[i].upper in char and s[i].lower in char):
        s1 = self.longestNiceSubstring(s[:i])
        s2 = self.longestNiceSubstring(s[i+1:])
        return s2 if len(s2) > len(s1) else s1
    return s


## 1876 Substrings of Size Three with Distinct Characters

class Solution:
  def countGoodSubstrings(self, s: str) -> int:
    count = 0
    for i in range(len(s)-2):
      if len(set(s[i:i+3])) == 3:
        count += 1
    return count

## 643 Maximum Average Subarray I
You are given an integer array nums consisting of n elements, and an integer k.
Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. 
Any answer with a calculation error less than 10-5 will be accepted.

Input: nums = [1,12,-5,-6,50,3], k = 4
Output: 12.75000
Explanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75
Input: nums = [5], k = 1
Output: 5.00000


class Solution:
  def findMaxAverage(self, nums: List[int], k:int) -> float:
    s = sum(nums[:k])
    maximum = s
    for i in range(1, len(nums)-k+1):
      s -= nums[i-1]
      s += nums[i+k-1]
      maximum = max(maximum, s)
    return maximum/k


#### 219. Contains Duplicate II
Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.
Input: nums = [1,2,3,1], k = 3
Output: true

Input: nums = [1,2,3,1,2,3], k = 2
Output: false


# Approach 1, Dictionary
class Solution:
  def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool: 
      d = {}
      for i, v in enumerate(nums):
        if v in d and i - d[v] <= k:
          return True
        d[v] = i
      return False

## Approach 2, Sliding Windows
class Solution:
  def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool: 
      windows = set()
      for i in range(0 , len(nums)):
        if len(windows) >= k+1:
          window.remove(nums[i-k-1])
        if nums[i] in windows:
          return True
        windows.add(nums[i])
      return False

## 1176 Diet Plan Performance

A dieter consumes calories[i] calories on the i-th day. 
Given an integer k, for every consecutive sequence of k days (calories[i], calories[i+1], ..., calories[i+k-1] for all 0 <= i <= n-k), they look at T, 
the total calories consumed during that sequence of k days (calories[i] + calories[i+1] + ... + calories[i+k-1]):
If T < lower, they performed poorly on their diet and lose 1 point; 
If T > upper, they performed well on their diet and gain 1 point;
Otherwise, they performed normally and there is no change in points.
Initially, the dieter has zero points. Return the total number of points the dieter has after dieting for calories.length days.
Note that the total points can be negative.

Input: calories = [1,2,3,4,5], k = 1, lower = 3, upper = 3
Output: 0
Explanation: Since k = 1, we consider each element of the array separately and compare it to lower and upper.
calories[0] and calories[1] are less than lower so 2 points are lost.
calories[3] and calories[4] are greater than upper so 2 points are gained.

Input: calories = [3,2], k = 2, lower = 0, upper = 1
Output: 1
Explanation: Since k = 2, we consider subarrays of length 2.
calories[0] + calories[1] > upper so 1 point is gained.

class Solution:
  def dietPlanPerformance(self, calories: List[int], k: int, lower:int, upper: int) -> int:
    ans = 0
    T = sum(calories[0:k])
    if T > upper: ans += 1
    if T < lower: ans -= 1
    for i in range(1, len(calories)-k+1):
      T -= calories[i-1]
      T += calories[i+k-1]
      if T > upper: ans += 1
      elif T < lower: ans -=1
      else:
        ans += 0
    return ans


## 209 Minimum Size Subarray Sum
Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, ..., numsr-1, numsr] 
of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead.

Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.
 

Input: target = 4, nums = [1,4,4]
Output: 1

Input: target = 11, nums = [1,1,1,1,1,1,1,1]
Output: 0

class Solution:
  def minSubArrayLen(self, target: int, nums: List[int]) -> int:
    left = 0
    right = 0
    total = 0
    ans = len(nums) + 1
    while right < len(nums):
      total += nums[right]
      while total >= target:
        ans = min(ans, right - left + 1)
        total -= nums[left]
        left += 1
      right += 1
    return ans if ans <= len(nums) else 0




## 159 Longest Substring with at Most 2 distinct Characters:

Given a string s, return the length of the longest substring that contains at most two distinct characters.
Input: s = "eceba"
Output: 3
Explanation: The substring is "ece" which its length is 3.

Input: s = "ccaabbb"
Output: 5
Explanation: The substring is "aabbb" which its length is 5.


class Solution:
  def lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:
    d = {}
    n = len(s)
    if n < 3:
      return n
    left = 0
    right = 0
    ans = 2   ## minimum length for 2 distinct chars
    
    while right < n:
      d[s[right]] = right
      right += 1
      
      if len(d) == 3:
        index = min(d.values())
        del d[s[index]]
        left = index + 1
      ans = max(ans, right - left)
    return ans



## 1852. Distinct Numbers in Each Subarray
Given an integer array nums and an integer k, you are asked to construct the array ans of size n-k+1 
where ans[i] is the number of distinct numbers in the subarray nums[i:i+k-1] = [nums[i], nums[i+1], ..., nums[i+k-1]].

Input: nums = [1,2,3,2,2,1,3], k = 3
Output: [3,2,2,2,3]
Explanation: The number of distinct elements in each subarray goes as follows:
- nums[0:2] = [1,2,3] so ans[0] = 3
- nums[1:3] = [2,3,2] so ans[1] = 2
- nums[2:4] = [3,2,2] so ans[2] = 2
- nums[3:5] = [2,2,1] so ans[3] = 2
- nums[4:6] = [2,1,3] so ans[4] = 3

Input: nums = [1,1,1,1,2,3,4], k = 4
Output: [1,2,3,4]
Explanation: The number of distinct elements in each subarray goes as follows:
- nums[0:3] = [1,1,1,1] so ans[0] = 1
- nums[1:4] = [1,1,1,2] so ans[1] = 2
- nums[2:5] = [1,1,2,3] so ans[2] = 3
- nums[3:6] = [1,2,3,4] so ans[3] = 4


class Solution:
  def distinctNumbers(self, nums: List[int], k:int) -> List[int]:
    c = collections.Counter(nums[:k])
    ## c can also = {} and then a for loop through nums[:k]
    res = []
    res.append(len(c))
    for i in range(k, len(nums)):
      if nums[i] in c:
        c[nums[i]] += 1
      else:
        c[nums[i]] = 1
      c[nums[i-k]] -= 1
      if c[nums[i-k]] == 0:
        c.pop(nums[i-k])
      res.append(len(c))
    return res

class Solution:
  def distinctNumbers(self, nums:List[int], k:int) -> List[int]:
    c = collections.Counter(nums[:k])
    cur = len(c)
    res = [cur]
    
    for i in range(k, len(nums)):
      c[nums[i-k]] -= 1
      if c[nums[i-k]] == 0:
        cur -= 1
      if c[nums[i]] == 0:
        cur += 1
      c[nums[i]] += 1
      res.append(cur)
    return res
      
## 1100 Find K-length Substrings With No Repeated Characters
Given a string s and an integer k, return the number of substrings in s of length k with no repeated characters.

Input: s = "havefunonleetcode", k = 5
Output: 6
Explanation: There are 6 substrings they are: 'havef','avefu','vefun','efuno','etcod','tcode'.

Input: s = "home", k = 5
Output: 0
Explanation: Notice k can be larger than the length of s. In this case, it is not possible to find any substring.

## Approach 1
class Solution:
  def numKLenSubstrNoRepeats(self, s: str, k: int) -> int:
    if k > len(s):
      return 0
    c = collections.Counter(s[:k])
    ans = 0
    if max(c.values()) == 1 and len(c) == k:
      ans += 1
    for i in range(k, len(s)):
      if s[i] not in c:
        c[s[i]] = 1
      else:
        c[s[i]] += 1
      c[s[i-k]] -= 1
      if c[s[i-k]] == 0:
        c.pop(s[i-k])
      if len(c) == k and all(value == 1 for value in c.values()):
        ans += 1
      else:
        continue
    return ans

Approach 2
class Solution:
    def numKLenSubstrNoRepeats(self, s: str, k: int) -> int:
        if len(s) < k:
            return 0
        
        self.points = 0
        currString = s[:k]
        self.checkDup(currString)
        
        for i in range(len(s) - k):
            currString = s[i+1:i+k+1]
            self.checkDup(currString)
        
        return self.points 
    
    def checkDup(self, currString):
        if len(currString) == len(set(currString)):
            self.points += 1

## 1343 Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold
Given an array of integers arr and two integers k and threshold.
Return the number of sub-arrays of size k and average greater than or equal to threshold.

Input: arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4
Output: 3
Explanation: Sub-arrays [2,5,5],[5,5,5] and [5,5,8] have averages 4, 5 and 6 respectively. All other sub-arrays of size 3 have averages less than 4 (the threshold).
 

Input: arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5
Output: 6
Explanation: The first 6 sub-arrays of size 3 have averages greater than 5. Note that averages are not integers.

class Solution:
  def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:
    sub_arr = sum(arr[:k])
    ans = 0
    l = k * threshold
    if sub_arr >= l:
      ans += 1
    for i in range(k, len(arr)):
      sub_arr -= arr[i-k]
      sub_arr += arr[i]
      if sub_arr >= l:
        ans += 1
    return ans



## 1358 Number of Substrings Containing All Three Characters:
Given a string s consisting only of characters a, b and c.
Return the number of substrings containing at least one occurrence of all these characters a, b and c.

Input: s = "abcabc"
Output: 10
Explanation: The substrings containing at least one 
occurrence of the characters a, b and c are "abc", "abca", "abcab", "abcabc", "bca", "bcab", "bcabc", "cab", "cabc" and "abc" (again). 

Input: s = "aaacb"
Output: 3
Explanation: The substrings containing at least one occurrence of the characters a, b and c are "aaacb", "aacb" and "acb". 

#################################################
Maintain a window which contains at least each character of a, b and c.
Once we found a window, rest part of that window will be a valid count.
So we can add len(s) - i on it.
################################################
class Solution:
  j = 0
  result = 0
  d = collections.Counter()
  for i, char in enumerate(s):
    d[char] += 1
    while len(d) == 3:
      result += len(s) - i
      d[s[j]] -= 1
      if d[s[j]] == 0:
        del d[s[j]]
      j += 1
  return result

## 1004. Max Consecutive Ones III
Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.

Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
Output: 6
Explanation: [1,1,1,0,0,1,1,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.

Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
Output: 10
Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
## My approach
class Solution:
  def longestOnes(self, nums: List[int], k:int) -> int:
    max_l = 0
    left = 0
    right = 0
    count_zero = 0
    while right < len(nums):
      if nums[right] == 0:
        count_zero += 1
      if count_zero <= k:
        max_l = max(max_l, right - left + 1)
      right += 1
      while count_zero > k:
        if nums[left] == 0:
          count_zero -= 1
        left += 1
   return max_l
  
#### Approach 2    
class Solution:
  left = right = 0
  for right in range(len(nums)):
    if nums[right] == 0:
      k -= 1
    if k < 0:
      if nums[left] == 0:
        k += 1
      left += 1
  return right - left + 1
    
    
## 1493. Longest Subarray of 1's after deleting 1 element
Given a binary array nums, you should delete one element from it.
Return the size of the longest non-empty subarray containing only 1's in the resulting array.
Return 0 if there is no such subarray.

Input: nums = [1,1,0,1]
Output: 3
Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.

Input: nums = [0,1,1,1,0,1,1,0,1]
Output: 5
Explanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1].

Input: nums = [1,1,1]
Output: 2
Explanation: You must delete one element.

Input: nums = [1,1,0,0,1,1,1,0,1]
Output: 4

Input: nums = [0,0,0]
Output: 0

class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        left = 0
        k = 1
        for right in range(len(nums)):
            if nums[right] == 0:
                k -= 1
            if k < 0:
                if nums[left] == 0:
                    k += 1
                left += 1
        return right - left 

## 1151. Minimum Swaps to Group All 1's Together
Given a binary array data, return the minimum number of swaps required to group all 1’s present in the array together in any place in the array.

Input: data = [1,0,1,0,1]
Output: 1
Explanation: 
There are 3 ways to group all 1's together:
[1,1,1,0,0] using 1 swap.
[0,1,1,1,0] using 2 swaps.
[0,0,1,1,1] using 1 swap.
The minimum is 1.

Input: data = [0,0,0,1,0]
Output: 0
Explanation: 
Since there is only one 1 in the array, no swaps needed.


class Solution:
  def minSwaps(self, data: List[int]) -> int:
    d = collections.Counter(data)
    if d[1] == 0 or d[1] == 1:
      return 0
    window = d[1]
    left = 0
    right = 0 
    count = 0
    ans = float('inf')
    while right < len(data):
      if data[right] ==0:
        count += 1
      if right - left + 1 == window:
        ans = min(ans, count)
        if data[left] == 0:
          count -= 1
        left += 1
      right += 1
    return ans



##487 Max Consecutive Ones II
Given a binary array nums, return the maximum number of consecutive 1's in the array if you can flip at most one 0.

Input: nums = [1,0,1,1,0]
Output: 4
Explanation: Flip the first zero will get the maximum number of consecutive 1s. After flipping, the maximum number of consecutive 1s is 4.

class Solution:
  def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
     left = 0
     right = 0
     ans = 0
     count = 0
     
     while right < len(nums):
        if nums[right] == 0:
          count += 1
        while count > 1:
          if nums[left] == 0:
            count -=1
          left += 1
        ans = max(ans, right - left + 1)
      right += 1
    return ans


##1248 Count Number of Nice Subarrays
Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.
Return the number of nice sub-arrays.

Input: nums = [1,1,2,1,1], k = 3
Output: 2
Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].

Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2
Output: 16

## Note, we need another count for the combinations compare to the traditional sliding windows


class Solution:
  def numberOfSubarrays(self, nums: List[int], k: int) -> int:
    left = 0
    right = 0
    ans = 0
    cur_sub_count = 0
    count_odd = 0
    
    for right in range(len(nums)):
      if nums[right] % 2 == 1:
        count_odd += 1
        cur_sub_count = 0
      while count_odd == k:
        if nums[left] % 2 == 1:
          count_odd -= 1
        cur_sub_count += 1
        left += 1
     ans += cur_sub_count
    return ans


##1052 Grumpy Bookstore Owner
There is a bookstore owner that has a store open for n minutes. Every minute, some number of customers enter the store. 
You are given an integer array customers of length n where customers[i] is the number of the customer that enters the store at the start of 
the ith minute and all those customers leave after the end of that minute.
On some minutes, the bookstore owner is grumpy. You are given a binary array grumpy where grumpy[i] is 1 if the bookstore owner is grumpy during the ith minute, 
and is 0 otherwise.
When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise, they are satisfied.
The bookstore owner knows a secret technique to keep themselves not grumpy for minutes consecutive minutes, but can only use it once.
Return the maximum number of customers that can be satisfied throughout the day.

Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3
Output: 16
Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. 
The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.

Input: customers = [1], grumpy = [0], minutes = 1
Output: 1

class Solution:
  def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:
      left = 0
      right = minutes
      cursum = 0
      maxsum = 0
      for i in range(len(customers)):
        if grumpy[i] == 0:
          cursum += customers[i]
      ## start the first window
      for i in range(minutes):
        if grumpy[i] != 0:
          cursum += customers[i]
      maxsum = cursum
      while right < len(customers):
        if grumpy[right] !=0:
          cursum += customers[right]
        if grumpy[left] != 0:
          cursum -= customers[left]
        maxsum = max(maxsum, cursum)
        right += 1
        left += 1
      return maxsum
      
      
## 1456. Maximum Number of Vowels in a Substring of Givern Length
Given a string s and an integer k.
Return the maximum number of vowel letters in any substring of s with length k.
Vowel letters in English are (a, e, i, o, u).

Input: s = "abciiidef", k = 3
Output: 3
Explanation: The substring "iii" contains 3 vowel letters.

Input: s = "aeiou", k = 2
Output: 2
Explanation: Any substring of length 2 contains 2 vowels.
class Solution:
    def maxVowels(self, s: str, k: int) -> int:
        count = 0
        vowel = {'a','e','i','o','u'}
        for i in s[0:k]:
            if i in vowel:
                count += 1
        max_vowel = count
        for right in range(k,len(s)):
            if s[right-k] in vowel:
                count -= 1
            if s[right] in vowel:
                count += 1
            max_vowel = max(max_vowel, count)
        return max_vowel



##b 1695 Maximum Erasure Value
You are given an array of positive integers nums and want to erase a subarray containing unique elements. 
The score you get by erasing the subarray is equal to the sum of its elements.
Return the maximum score you can get by erasing exactly one subarray.
An array b is called to be a subarray of a if it forms a contiguous subsequence of a, that is, if it is equal to a[l],a[l+1],...,a[r] for some (l,r).

Input: nums = [4,2,4,5,6]
Output: 17
Explanation: The optimal subarray here is [2,4,5,6].

Input: nums = [5,2,1,2,5,2,1,2,5]
Output: 8
Explanation: The optimal subarray here is [5,2,1] or [1,2,5].

class Solution:
  def maximumUniqueSubarray(self, nums: List[int]) -> int:
    s =set()
    left = 0
    right = 0
    max_score = 0
    score = 0
    while right < len(nums):
      if nums[right] not in s:
        score += nums[right]
        s.add(nums[right])
        right += 1
        max_score = max(max_score, score)
      else:
        score -= nums[left]
        s.remove(nums[left])
        left += 1
   return max_score


## 438 Find All Anagrams in a String
Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

Input: s = "cbaebabacd", p = "abc"
Output: [0,6]
Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".

Input: s = "abab", p = "ab"
Output: [0,1,2]
Explanation:
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".

class Solution:
  def finAnagrams(self, s: str, p: str) -> List[int]:
    window = len(p)
    N = len(s)
    d = collections.Counter(p)
    a = collections.Counter()
    res = []
    for i in range(0, N):
      a[s[i]] += 1
      if i >= window:
        if a[s[i-window]] == 1:
          del a[s[i- window]]
        a[s[i- window]] -= 1
      if a == d:
        res.append(i - window + 1)
    return res
    
    
## 1208 Get Equal Substrings Within Budget
You are given two strings s and t of the same length. You want to change s to t. 
Changing the i-th character of s to i-th character of t costs |s[i] - t[i]| that is, the absolute difference between the ASCII values of the characters.
You are also given an integer maxCost.
Return the maximum length of a substring of s that can be changed to be the same as the corresponding substring of twith a cost less than or equal to maxCost.
If there is no substring from s that can be changed to its corresponding substring from t, return 0.

Input: s = "abcd", t = "bcdf", maxCost = 3
Output: 3
Explanation: "abc" of s can change to "bcd". That costs 3, so the maximum length is 3.

 
Input: s = "abcd", t = "acde", maxCost = 0
Output: 1
Explanation: You can't make any change, so the maximum length is 1.


class Solution:
  def equalSubstring(self, s:str, t:str, maxCost:int) -> int:
    i = 0 
    for j in range(len(s)):
      maxCost -= abs(ord(s[j]) - ord(t[j]))
      if maxCost < 0:
        maxCost += abs(ord(s[i]) - ord(t[i]))
        i += 1
    return j - i + 1


##930 Binary Subarays With Sum
Given a binary array nums and an integer goal, return the number of non-empty subarrays with a sum goal.
A subarray is a contiguous part of the array.
Input: nums = [1,0,1,0,1], goal = 2
Output: 4
Explanation: The 4 subarrays are bolded and underlined below:
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]

Input: nums = [0,0,0,0,0], goal = 0
Output: 15

class Solution:
  def numSubarrayWithSum(self, nums: List[int], goal: int) -> int:
    n = len(nums)
    if sum(nums) == 0 and goal == 0:
      return sum(range(1,n+1))
    right = 0
    left = 0
    res, count, ans = 0,0,0
    for right in range(0,n):
      res += nums[right]
      if nums[right] == 1:
        count = 0
      while left <= right and res >= goal:
        if res == goal:
          count += 1
        res -= nums[left]
        left += 1
      ans += count
    return ans
    
    
    




















    
    
    
    
   

## 1031 Maximum Sum of Two Non-Overlapping Subarrays
Given an integer array nums and two integers firstLen and secondLen, 
return the maximum sum of elements in two non-overlapping subarrays with lengths firstLen and secondLen.
The array with length firstLen could occur before or after the array with length secondLen, but they have to be non-overlapping.
A subarray is a contiguous part of an array.

Input: nums = [0,6,5,2,2,5,1,9,4], firstLen = 1, secondLen = 2
Output: 20
Explanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2.

Input: nums = [3,8,1,3,2,1,8,9,0], firstLen = 3, secondLen = 2
Output: 29
Explanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2.

Input: nums = [2,1,5,6,0,9,5,0,3,8], firstLen = 4, secondLen = 3
Output: 31
Explanation: One choice of subarrays is [5,6,0,9] with length 4, and [3,8] with length 3.

################ Think about prefix sum and sliding window


class Solution:
  def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:
    if len(nums) < firstLen + secondLen:
      return 0
    for i in range(1, len(nums)):
      nums[i] += nums[i-1]
    max_f_len = nums[firstLen -1]
    max_s_len = nums[secondLen - 1]
    res = nums[firstLen + secondLen -1]
    
    for i in range(firstLen + secondLen, len(nums)):
      max_f_len = max(max_f_len, nums[i-secondLen] - nums[i-secondLen - firstLen])
      max_s_len = max(max_s_len, nums[i-firstLen] - nums[i - firstLen - secondLen])
      res = max(res, max_s_len + nums[i] - nums[i - firstLen], max_f_len + nums[i] - nums[i-secondLen])
    return res





## 1918 Kth Smallest Subarray Sum

Given an integer array nums of length n and an integer k, return the kth smallest subarray sum.
A subarray is defined as a non-empty contiguous sequence of elements in an array. A subarray sum is the sum of all elements in the subarray.
Input: nums = [2,1,3], k = 4
Output: 3
Explanation: The subarrays of [2,1,3] are:
- [2] with sum 2
- [1] with sum 1
- [3] with sum 3
- [2,1] with sum 3
- [1,3] with sum 4
- [2,1,3] with sum 6 
Ordering the sums from smallest to largest gives 1, 2, 3, 3, 4, 6. The 4th smallest is 3.

Input: nums = [3,3,5,5], k = 7
Output: 10
Explanation: The subarrays of [3,3,5,5] are:
- [3] with sum 3
- [3] with sum 3
- [5] with sum 5
- [5] with sum 5
- [3,3] with sum 6
- [3,5] with sum 8
- [5,5] with sum 10
- [3,3,5], with sum 11
- [3,5,5] with sum 13
- [3,3,5,5] with sum 16
Ordering the sums from smallest to largest gives 3, 3, 5, 5, 6, 8, 10, 11, 13, 16. The 7th smallest is 10.
 
## Think about sliding window and binary search
##############################################################################################################################
Explanation
Based on the hint section, we can find number of subarray-sum less than x, so that local the kth smallest number among all subarrays using binary search.
Imagine we find all subarray-sum for some array and sort them, the kth smallest subarray-sum, will lay between the minimum sum and the maximum sum.
We don't necessarily need to find all subarray-sum, nor sort them
Instead, since we know the range, we can use binary search to locate the kth smallest
Essentially, using a binary search is to eliminate the subarray-sums which contains more than k values
At the of the binary search, the lower & upper bound will crossover.
The lower bound tells us, there are k sums that less than this lower bound, which makes this lower bound the kth smallest value, or the largest among these k sums.
To find number of subarray-sum less than x, we can iterate the array while maintaining two pointers to count how many valid subarrays are there. 
The time complexity of this process is O(n) because each element is visited twice at max. (n is the length of the array)
Time complexity: O(Nlog(N)), where N is the length of the array. Binary search takes O(log(N*(N+1)/2)) = O(log(N^2)) = O(2logN) = O(logN). 
Finding subarray-sum less than x takes O(N) as mentioned before.
Space Complexity: O(1)
################################################################################################################################

 class Solution:
  def kthSmallestSubarraySum(self, nums: List[int], k:int) -> int:
    lo = min(nums)
    hi = sum(nums)
    while lo <= hi:
      mid = lo + (hi-lo)//2
      if k <= self.number_of_subarray_smaller_than_x(mid, nums):
        hi = mid -1
      else:
        lo = mid +1
    return lo
  
  def number_of_subarray_smaller_than_x(self, x , nums):
    j = 0
    count = 0
    cur = 0
    for i in range(len(nums)):
      cur += nums[i]
      while cur > x:
        cur -= nums[j]
        j += 1
      count += j-i+1
    return count
        
## 1297 Maximum Number of Occurences of a Substring:
Given a string s, return the maximum number of ocurrences of any substring under the following rules:
The number of unique characters in the substring must be less than or equal to maxLetters.
The substring size must be between minSize and maxSize inclusive.
    
Input: s = "aababcaab", maxLetters = 2, minSize = 3, maxSize = 4
Output: 2
Explanation: Substring "aab" has 2 ocurrences in the original string.
It satisfies the conditions, 2 unique letters and size 3 (between minSize and maxSize).

Input: s = "aaaa", maxLetters = 1, minSize = 3, maxSize = 3
Output: 2
Explanation: Substring "aaa" occur 2 times in the string. It can overlap.

Input: s = "aabcabcab", maxLetters = 2, minSize = 2, maxSize = 3
Output: 3

Input: s = "abcde", maxLetters = 2, minSize = 3, maxSize = 3
Output: 0

class Solution:
    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:
        res = []
        if minSize == maxSize:
            tmp = s[0:minSize]
            if len(set(tmp)) <= maxLetters:
                res.append(tmp)
            for i in range(minSize, len(s)):
                tmp = tmp[1:]
                tmp += s[i]
                if len(set(tmp)) <= maxLetters:
                    res.append(tmp)
        else:
            tmp1 = s[0:minSize]
            if len(set(tmp1)) <= maxLetters:
                res.append(tmp1)
            for i in range(minSize, len(s)):
                tmp1 = tmp1[1:]
                tmp1 += s[i]
                if len(set(tmp1)) <= maxLetters:
                    res.append(tmp1)
            tmp2 = s[0:maxSize]
            if len(set(tmp2)) <= maxLetters:
                res.append(tmp2)
            for i in range(maxSize, len(s)):
                tmp2  = tmp2[1:]
                tmp2 += s[i]
                if len(set(tmp2)) <= maxLetters:
                    res.append(tmp2)
        ans = collections.Counter(res)
        print(ans)
        return max(ans.values()) if ans else 0
                
## 1423 Maximum Points You can Obtain from cards
There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints.
In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards.
Your score is the sum of the points of the cards you have taken.
Given the integer array cardPoints and the integer k, return the maximum score you can obtain.

Input: cardPoints = [1,2,3,4,5,6,1], k = 3
Output: 12
Explanation: After the first step, your score will always be 1. 
However, choosing the rightmost card first will maximize your total score. 
The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12.

class Solution:
  def maxScore(self, cardPoints: List[int], k:int) -> int:
    res = sum(cardPoints[:k])
    ans = res
    
    if k >= len(cardPoints):
      return ans
      
    left = k - 1
    right = -1
    for _ in range(k):
      res = res - cardPoints[left] + cardPoints[right]
      ans = max(ans, res)
      right -= 1
      left -= 1
    return ans
    
    

### 718 Maximum Length of Repeated Subarray


Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays.
Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
Output: 3
Explanation: The repeated subarray with maximum length is [3,2,1].


Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
Output: 5

class Solution:
  def findLenhgth(self, nums1: List[int], nums2: LIst[int]) -> int:
    n = len(nums1)
    m = nums(nums2)
    count = 0
    
    t = [[0]*(m+1) for _ in range(n+1)]
    for i in range(n+1):
      for j in range(m+1):
        if nums1[i-1] == nums2[j-1]:
          t[i][j] = t[i-1][j-1] +1
          count = max(count, t[i][j])
     return count


### 424 Longest repeating Character Replacement
You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. 
You can perform this operation at most k times.
Return the length of the longest substring containing the same letter you can get after performing the above operations.

Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.

Input: s = "AABABBA", k = 1
Output: 4
Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.

class Solution:
  def characterReplacement(self, s: str, k: int) -> int:
    d = {}
    j = 0
    max_sub = 0
    for i in range(len(s)):
      if s[i] not in d:
        d[s[i]] = 1
      else:
        d[s[i]] += 1
      while (i + 1 - j - max(d.values())) > k:
        d[s[j]] -= 1
        j +=1
      max_sub = max(max_sub, i + 1 - j)
   return max_sub


## 1839 Longest Substring Of All Vowels in Order
A string is considered beautiful if it satisfies the following conditions:

Each of the 5 English vowels ('a', 'e', 'i', 'o', 'u') must appear at least once in it.
The letters must be sorted in alphabetical order (i.e. all 'a's before 'e's, all 'e's before 'i's, etc.).
For example, strings "aeiou" and "aaaaaaeiiiioou" are considered beautiful, but "uaeio", "aeoiu", and "aaaeeeooo" are not beautiful.

Given a string word consisting of English vowels, return the length of the longest beautiful substring of word. If no such substring exists, return 0.

A substring is a contiguous sequence of characters in a string.

Input: word = "aeiaaioaaaaeiiiiouuuooaauuaeiu"
Output: 13
Explanation: The longest beautiful substring in word is "aaaaeiiiiouuu" of length 13.

Input: word = "aeeeiiiioooauuuaeiou"
Output: 5
Explanation: The longest beautiful substring in word is "aeiou" of length 5.

class Solution:
  def longestBeautifulSubstring(self, word:str) -> int:
    left = 0
    right = 0
    res = 0
    while right < len(word):
      if word[right] in ['a','e','i','o','u'] and (word[right-1] <= word[right] or right == 0):
        right += 1
      else:
        if len(set(word[left:right])) == 5:
          res = max(res, right - left)
          left = right
          right += 1
      if len(set(word[left:right])) == 5:
          res = max(res, right - left)
      return res
      
      
      
class Solution:
  def longestBeautifulSubstring(self, word:str) -> int:    
      d = {}
      d['a'] = {'a','e'}
      d['e'] = {'e','i'}
      d['i'] = {'i','o'}
      d['o'] = {'o','u'}
      d['u'] = {'u'}
     
      stack = []
      res = 0
      for c in word:
        if len(stack) == 0:
            if c == 'a':
                stack.append(c)
            continue
        if c in d[stack[-1]]:
            stack.append(c)
            if c == 'u':
                res = max(res, len(stack))
        else:
            stack = [] if c != 'a' else ['a']
     return res



## 904 Fruit Into baskets
You are visiting a farm that has a single row of fruit trees arranged from left to right. 
The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces.

You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:

You only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold.
Starting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. 
The picked fruits must fit in one of your baskets.
Once you reach a tree with fruit that cannot fit in your baskets, you must stop.
Given the integer array fruits, return the maximum number of fruits you can pick.

Input: fruits = [1,2,1]
Output: 3
Explanation: We can pick from all 3 trees.

Input: fruits = [0,1,2,2]
Output: 3
Explanation: We can pick from trees [1,2,2].
If we had started at the first tree, we would only pick from trees [0,1].

class Solution:
  def totalFruits(self, fruits: List[int]) -> int:
    left = 0
    right = 0
    res = 0
    count = 0
    d = {}
    if len(friuts) <= 2:
      return len(fruits)
    
    whiel right < len(fruits):
      if fruits[right] not in d:
        d[fruits[right]] =1
      else:
        d[fruits[right]] += 1
      if len(d) <=2:
        count = max(sum(d.values()))
      res = max(res, count)
      if len(d) > 2:
        d[fruits[left]] -= 1
        if d[fruits[left]] = 0：
          del d[fruits[left]]
        left += 1
      right += 1
   return res


## 713 Subarray Product Less Than K
Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.

Input: nums = [10,5,2,6], k = 100
Output: 8
Explanation: The 8 subarrays that have product less than 100 are:
[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]
Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.

class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        left = 0
        right = 0
        prod = 1
        ans = 0
        if k <= 1:
            return 0
        for right in range(len(nums)):
            prod *= nums[right]
            while prod >= k:
                prod /= nums[left]
                left += 1
            ans += right - left +1
        
        return ans

## 340 Longest Substring With At Most K Distinct Characters
Given a string s and an integer k, return the length of the longest substring of s that contains at most k distinct characters.


Input: s = "eceba", k = 2
Output: 3
Explanation: The substring is "ece" with length 3.

Input: s = "aa", k = 1
Output: 2
Explanation: The substring is "aa" with length 2.

class Solution:
    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:
        d = {}
        res = 0
        j = 0
        for i in s:
            if i not in d:
                d[i] = 1
            else:
                d[i] += 1
            if len(d) <= k:
                res = max(res, sum(d.values()))
            if len(d) > k:
                d[s[j]] -=1
                if d[s[j]] == 0:
                    del d[s[j]]
                j += 1
        return res

## 187 Repeated DNA Sequences
The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.

For example, "ACGAATTCCG" is a DNA sequence.
When studying DNA, it is useful to identify repeated sequences within the DNA.

Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. 
You may return the answer in any order.

Input: s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"
Output: ["AAAAACCCCC","CCCCCAAAAA"]

Input: s = "AAAAAAAAAAAAA"
Output: ["AAAAAAAAAA"]

class Solution:
    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        seen = set()
        output = set()
        n = len(s)
        
        
        for i in range(0, n - 10 + 1):
            tmp = s[i:i+10]
            if tmp in seen:
                output.add(tmp)
            seen.add(tmp)
        return output
            
            
## 1234 Replace the Substring for balanced String
You are given a string containing only 4 kinds of characters 'Q', 'W', 'E' and 'R'.

A string is said to be balanced if each of its characters appears n/4 times where n is the length of the string.

Return the minimum length of the substring that can be replaced with any other string of the same length to make the original string s balanced.

Return 0 if the string is already balanced.

Input: s = "QWER"
Output: 0
Explanation: s is already balanced.


Input: s = "QQQW"
Output: 2
Explanation: We can replace the first "QQ" to "ER". 

## Note: Substrings not separated characters

class Solution:
  def balancedString(self, s:str) -> int:
      show_times = len(s)/4
      d = {}
      extra = {}
      for i in s:
        if i not in d:
          d[i] = 1
        else:
          d[i] += 1
      for i in d:
        if d[i] > show_times:
          extra[i] = d[i] - show_times
      if not extra:
        return 0
      left = 0
      right = 0
      res = len(s)
      for right in range(res):
        if s[right] in extra:
          extra[s[right]] -= 1
        while max(extra.values()) <= 0:
          res = min(res, right - left + 1)
          if s[left] in extra:
            extra[s[left]] -= 1
          left += 1
     return res


## 220 Contain Du[licate III
Given an integer array nums and two integers k and t, 
return true if there are two distinct indices i and j in the array such that abs(nums[i] - nums[j]) <= t and abs(i - j) <= k.

Input: nums = [1,2,3,1], k = 3, t = 0
Output: true

Input: nums = [1,0,1,1], k = 1, t = 2
Output: true

Input: nums = [1,5,9,1,5,9], k = 2, t = 3
Output: false

## Solution: Bucket Sort
# Bucket sort. Each bucket has size of t. For each number, the possible
    # candidate can only be in the same bucket or the two buckets besides.
    # Keep as many as k buckets to ensure that the difference is at most k.

class Solution:
  def containsNearbyAlmostDuplicate(self, nums: List[int], k:int, t:int) -> bool:
    if t < 0:
      return False
    d = {}
    for i in range(len(nums)):
        m = nums[i] //(t+1)
        if m in d or (m-1 in d and nums[i] - d[m-1] <= t) or (m + 1 in d and nums[i] - d[m+1] <= t):
          return True
        d[m] = nums[i]
        if i >=k:
          del d[num[i-k] // (t+1)]
    return False

## 978 Longest Turbulen Subarray
Given an integer array arr, return the length of a maximum size turbulent subarray of arr.

A subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.

More formally, a subarray [arr[i], arr[i + 1], ..., arr[j]] of arr is said to be turbulent if and only if:

For i <= k < j:
arr[k] > arr[k + 1] when k is odd, and
arr[k] < arr[k + 1] when k is even.
Or, for i <= k < j:
arr[k] > arr[k + 1] when k is even, and
arr[k] < arr[k + 1] when k is odd.

Input: arr = [9,4,2,10,7,8,8,1,9]
Output: 5
Explanation: arr[1] > arr[2] < arr[3] > arr[4] < arr[5]


Input: arr = [4,8,12,16]
Output: 2


Input: arr = [100]
Output: 1


class Solution:
  def maxTurbulenceSize(self, arr: List[int]) -> int:
    left = 0
    right = 0
    res = 0
    n = len(arr)
    while right < n:
      while l < n-1 and arr[l] == arr[l+1]:
        l += 1
      while r < n-1 and (arr[l-1] < arr[l] > arr[l+1] or arr[l-1] > arr[l] < arr[l+1] ):
        r += 1
      res = max(res, right - left +1)
      left = right
      right += 1
    return res
     
## 1438 Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit
Given an array of integers nums and an integer limit, 
return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.

Input: nums = [8,2,4,7], limit = 4
Output: 2 
Explanation: All subarrays are: 
[8] with maximum absolute diff |8-8| = 0 <= 4.
[8,2] with maximum absolute diff |8-2| = 6 > 4. 
[8,2,4] with maximum absolute diff |8-2| = 6 > 4.
[8,2,4,7] with maximum absolute diff |8-2| = 6 > 4.
[2] with maximum absolute diff |2-2| = 0 <= 4.
[2,4] with maximum absolute diff |2-4| = 2 <= 4.
[2,4,7] with maximum absolute diff |2-7| = 5 > 4.
[4] with maximum absolute diff |4-4| = 0 <= 4.
[4,7] with maximum absolute diff |4-7| = 3 <= 4.
[7] with maximum absolute diff |7-7| = 0 <= 4. 
Therefore, the size of the longest subarray is 2.

Input: nums = [10,1,2,4,7,2], limit = 5
Output: 4 
Explanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 <= 5.


Input: nums = [4,2,2,2,4,4,2,2], limit = 0
Output: 3

## Note: Implement 2 deque to find min and max that could pop left and pop right to do this with sliding window
class Solution:
  def longestSubarray(self, nums: List[int], limit:int) -> int:
    max_len = 1
    i = 0
    minqueue = collections.deque()
    maxqueue = collections.deque()
    for j in range(len(nums)):
      while minqueue and minqueue[-1] > nums[j]:
        minqueue.pop()
      minqueue.append(nums[j])
      while maxqueue and maxqueue[-1] < nums[j]:
        maxqueue.pop()
      maxqueue.append(nums[j])
      
      if maxqueue[0] - minqueue[0] <= limit:
        max_len = max(max_len, j - i + 1)
      else:
        if maxqueue[0] == nums[j]:
          maxqueue.popleft()
        if minqueue[0] == nums[j]:
          minqueue.popleft()
        i += 1
   return max_len


## 395 Longest Substring with At Least K repeating Characters
Given a string s and an integer k, return the length of the longest substring of s such that the frequency of each character in this substring is greater than or equal to k.

Input: s = "aaabb", k = 3
Output: 3
Explanation: The longest substring is "aaa", as 'a' is repeated 3 times.

Input: s = "ababbc", k = 2
Output: 5
Explanation: The longest substring is "ababb", as 'a' is repeated 2 times and 'b' is repeated 3 times.


### Recursion 
class Solution:
  def longestSubstring(self, s: str, k: int) -> int:
    d = collections.Counter(s)
    if len(s) == 0 or k > len(s):
      return 0
    
    s1 = ''
    s2 = ''
    for i in range(len(s)):
      if d[s[i]] < k:
        s1 = self.longestSubstring(s[:i], k)
        s2 = self.longestSubstring(s[i+1:], k)
        break
    else:
      return len(s)
    return max(s1,s2)


## Sliding Window
Intuition
There is another intuitive method to solve the problem by using the Sliding Window Approach. 
The sliding window slides over the string s and validates each character. Based on certain conditions, the sliding window either expands or shrinks.
A substring is valid if each character has at least k frequency. 
The main idea is to find all the valid substrings with a different number of unique characters and track the maximum length. Let's look at the algorithm in detail.

Algorithm
Find the number of unique characters in the string s and store the count in variable maxUnique. For s = aabcbacad, the unique characters are a,b,c,d and maxUnique = 4.
Iterate over the string s with the value of currUnique ranging from 1 to maxUnique. 
In each iteration, currUnique is the maximum number of unique characters that must be present in the sliding window.
The sliding window starts at index windowStart and ends at index windowEnd and slides over string s until windowEnd reaches the end of string s. 
At any given point, we shrink or expand the window to ensure that the number of unique characters is not greater than currUnique.
If the number of unique character in the sliding window is less than or equal to currUnique, 
expand the window from the right by adding a character to the end of the window given by windowEnd
Otherwise, shrink the window from the left by removing a character from the start of the window given by windowStart.
Keep track of the number of unique characters in the current sliding window having at least k frequency given by countAtLeastK. 
Update the result if all the characters in the window have at least k frequency.


First of all, be careful with this problem formulation: Given a string s and an integer k, 
return the length of the longest substring of s such that the frequency of each character in this substring is less than or equal to k : 
this is not correct statement, what you actually asked is is more than or equal to k. I spend some time figuring it out.
Now, we will use sliding window approach to find the window of biggest length. 
However, it is not that easy. Imagine, that we have s = aabbb... and k = 3, what should we do when we reached window aabbb: 
should we expand it to the right hoping that we will meet another a? Or should we start to move left side of our window? 
One way to handle this problem is to do several sliding windows passes, where we fix T number of different symbols we must have in our substring. 
So, we check all posible T = 1, ... 26 (if fact, not 26, but len(Counter(s)) + 1)) and do sliding window pass:

Initialize beg = 0, end = 0, Found = 0: number of elements with frequency more or equal than k, freq is array of frequencies = [0]*26 and MoreEqK = 0, 
which count number of non-zero frequencies in our freq array.
Now, we check if MoreEqK <=T or not, that is we have T or less different symbols in our window: then we can add element to to right part of our sliding window: 
we increase its frequency, if this symbol is new, that is frequency become equal to 1, we increment MoreEqK. Also, if frequency become equal to k, we increment Found.
In opposite case it means, that we already have T+1 or more different symbols in or window, so we need to move left side of our sliding window. 
Again, we check if frequency was equal to k and if it was, we decrease Found by one, if frequency become equal to zero, we decrease MoreEqK.
Finally, if we have exactly T non-zero frequencies and all T of them more or equal than k, we update our result.
Complexity: time complexity is O(26n), because we can potentially have 26 passes over our data. Space complexity is O(26). 
Yes, I understand, that O(26n) = O(n), but here I want to stress that constant is quite big.


class Solution:
    def longestSubstring(self, s, k):
        result = 0
        for T in range(1, len(Counter(s))+1):
            beg, end, Found, freq, MoreEqK = 0, 0, 0, [0]*26, 0
            while end < len(s):
                if MoreEqK <= T:
                    s_new = ord(s[end]) - 97
                    freq[s_new] += 1
                    if freq[s_new] == 1:
                        MoreEqK += 1
                    if freq[s_new] == k:
                        Found += 1
                    end += 1
                else:
                    symb = ord(s[beg]) - 97
                    beg += 1
                    if freq[symb] == k:
                        Found -= 1
                    freq[symb] -= 1
                    if freq[symb] == 0:
                        MoreEqK -= 1
                            
                if MoreEqK == T and Found == T:
                    result = max(result, end - beg)
                    
        return result

class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        hsh, res = defaultdict(list), 0
        
        for i, ch in enumerate(s):
            hsh[ch].append(i)
            flag, ed, ranges = True, -1, [] 
            for letter in ascii_lowercase:
                if len(hsh[letter]) != 0 and len(hsh[letter]) < k:
                    ed = max(hsh[letter][-1], ed)
                if len(hsh[letter]) != 0 and len(hsh[letter]) >= k:
                    ranges.append([hsh[letter][-k], hsh[letter][-1]])
            for start, end in sorted(ranges):
                if ed > start:
                    ed = max(ed, end)
            res = max(res, i - ed)
        
        return res
                




## 1477 Find Two Non-overlapping Sub-arrays Each with Target Sum
Given an array of integers arr and an integer target.
You have to find two non-overlapping sub-arrays of arr each with a sum equal target. 
There can be multiple answers so you have to find an answer where the sum of the lengths of the two sub-arrays is minimum.
Return the minimum sum of the lengths of the two required sub-arrays, or return -1 if you cannot find such two sub-arrays.

Input: arr = [3,2,2,4,3], target = 3
Output: 2
Explanation: Only two sub-arrays have sum = 3 ([3] and [3]). The sum of their lengths is 2.

Input: arr = [7,3,4,7], target = 7
Output: 2
Explanation: Although we have three non-overlapping sub-arrays of sum = 7 ([7], [3,4] and [7]), 
but we will choose the first and third sub-arrays as the sum of their lengths is 2.

Input: arr = [7,3,4,7], target = 7
Output: 2
Explanation: Although we have three non-overlapping sub-arrays of sum = 7 ([7], [3,4] and [7]), 
but we will choose the first and third sub-arrays as the sum of their lengths is 2.

## Solution Video
https://www.youtube.com/watch?v=63K9MYDfEEc&list=PL3y3hORdLwp7BfOrCyXi2bSv13ZctfUQW&index=4&ab_channel=RickyCho    

class Solution:
    def minSumOfLengths(self, arr: List[int], target: int) -> int:
        mins = [float('Inf')]* len(arr)
        left = 0 
        right = 0
        curr_sum = 0
        output = float('Inf')
        
        for right in range(len(arr)):
            curr_sum += arr[right]
            while curr_sum > target and left <= right:
                curr_sum -= arr[left]
                left += 1
            
            if curr_sum == target:
                output = min(output, mins[left -1] + right - left + 1)
                mins[right] = min(mins[right-1], right - left + 1)
            else:
                mins[right] = mins[right-1]
            
        if output == float('inf'):
            return -1
        return output


## 567 Permutation in String
Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.
In other words, return true if one of s1's permutations is the substring of s2.

Input: s1 = "ab", s2 = "eidbaooo"
Output: true
Explanation: s2 contains one permutation of s1 ("ba").

Input: s1 = "ab", s2 = "eidboaoo"
Output: false

class Solution:
  def checkInclusion(self, s1: str, s2: str) -> str:
    n = len(s1)
    d1 = collections.Counter(s1)
    d2 = collections.Counter(s2[:n])
    for start in range(n, len(s2)):
      if d1 == d2:
        return True
      d2[s2[start]] += 1
      d2[s2[start-n]] -= 1
      if d2[s2[start-n]] == 0:
        del d2[s2[start-n]]
    return d1 == d2
    

## 1156 Swap For Longest repeated Character Substring
You are given a string text. You can swap two of the characters in the text.
Return the length of the longest substring with repeated characters.

Input: text = "ababa"
Output: 3
Explanation: We can swap the first 'b' with the last 'a', or the last 'b' with the first 'a'. 
Then, the longest repeated character substring is "aaa", which its length is 3.

Input: text = "aaabaaa"
Output: 6
Explanation: Swap 'b' with the last 'a' (or the first 'a'), and we get longest repeated character substring "aaaaaa", which its length is 6.

Input: text = "aaabbaaa"
Output: 4

Input: text = "aaaaa"
Output: 5
Explanation: No need to swap, longest repeated character substring is "aaaaa", length is 5.

Input: text = "abcdef"
Output: 1

class Solution:
  def maxRepOpt1(self, text:str) -> int:
    N = len(text)
    max_alpha = text[0]
    max_char = 0
    res = 0
    left = 0
    right = 0
    alphas = collections.defaultdict(int)
    count = collections.Counter(text)
    
    while right < N:
      alphas[text[right]] += 1
      if max_char < alphas[text[right]]:
        max_alpha = text[right]
        max_char = alphas[text[right]]
      if count[max_alpha] = alphas[max_alpha] and right - left - max_char + 1 == 1:
        left = right
        alphas[max_alpha] = 0
        max_alpha = text[left]
      while right - left - max_char +1 > 1:
        alphas[text[left]] -= 1
        left += 1
      window = max(window, right - left + 1)
      right += 1
    return window


## 1696 Jump Game VI
################### it is a good question to apply deque

You are given a 0-indexed integer array nums and an integer k.
You are initially standing at index 0. In one move, you can jump at most k steps forward without going outside the boundaries of the array. 
That is, you can jump from index i to any index in the range [i + 1, min(n - 1, i + k)] inclusive.
You want to reach the last index of the array (index n - 1). Your score is the sum of all nums[j] for each index j you visited in the array.
Return the maximum score you can get.

Input: nums = [1,-1,-2,4,-7,3], k = 2
Output: 7
Explanation: You can choose your jumps forming the subsequence [1,-1,4,3] (underlined above). The sum is 7.


Input: nums = [10,-5,-2,4,0,3], k = 3
Output: 17
Explanation: You can choose your jumps forming the subsequence [10,4,3] (underlined above). The sum is 17.


Input: nums = [1,-5,-20,4,-1,3,-6,-3], k = 2
Output: 0


class Solution:
  def maxResult(self, nums: List[int], k: int) -> int:
    n = len(nums)
    score = [0] * n
    score[0] = nums[0]
    q = deque([(nums[0],0)])
    for i in range(1,n):
      score[i] = q[0][0] + nums[i]
      while q and score[i] > q[-1][0]:
        q.pop()
      q.append((score[i],i))
      
      if i - k == q[0][1]:
        q.popleft()
    return score[-1]


### 837 New 21 Game
Alice plays the following game, loosely based on the card game "21".
Alice starts with 0 points and draws numbers while she has less than k points. 
During each draw, she gains an integer number of points randomly from the range [1, maxPts], where maxPts is an integer. 
Each draw is independent and the outcomes have equal probabilities.
Alice stops drawing numbers when she gets k or more points.
Return the probability that Alice has n or fewer points.
Answers within 10-5 of the actual answer are considered accepted.

Input: n = 10, k = 1, maxPts = 10
Output: 1.00000
Explanation: Alice gets a single card, then stops.


Input: n = 6, k = 1, maxPts = 10
Output: 0.60000
Explanation: Alice gets a single card, then stops.
In 6 out of 10 possibilities, she is at or below 6 points.

Input: n = 21, k = 17, maxPts = 10
Output: 0.73278

## Dynamic Programming
## dp(x) = (dp(x+1) + dp(x+2) + .... + dp(x+ maxPts))/maxPts
### dp(x-1) = (dp(x) + dp(x+1) + .... + dp(x+ maxPts-1))/maxPts
--->  dp(x-1) = (dp(x) - dp(x+maxPts)) / maxPts

## First we need a dp with length of n + maxPts incase of out of index
## second we need to assign value to dp
## thirdly we determine the dp(k-1)'s probability and go with -1 till 0

class Solution
  def new21Game(self, n: int, k:int, maxPts: int) -> float:
      dp = [0] * (n + maxPts)
      for i in range(k, min(n+1, k + maxPts)):
        dp[i] = 1
      s = min(n-k+1, maxPts)
      for i in range(k-1, -1, -1):
        dp[i] = s / float(maxPts)
        s += dp[i] - dp[i + maxPts]
      return dp[0]
      





























