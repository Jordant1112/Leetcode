## 1763. Longest Nice Substring
A string s is nice if, for every letter of the alphabet that s contains, it appears both in uppercase and lowercase. For example, 
"abABB" is nice because 'A' and 'a' appear, and 'B' and 'b' appear. However, "abA" is not because 'b' appears, but 'B' does not.
Given a string s, return the longest substring of s that is nice. If there are multiple, return the substring of the earliest occurrence. 
If there are none, return an empty string.

Input: s = "YazaAay"
Output: "aAa"
Explanation: "aAa" is a nice string because 'A/a' is the only letter of the alphabet in s, and both 'A' and 'a' appear.
"aAa" is the longest nice substring.

Input: s = "Bb"
Output: "Bb"
Explanation: "Bb" is a nice string because both 'B' and 'b' appear. The whole string is a substring.

Input: s = "c"
Output: ""
Explanation: There are no nice substrings.

Input: s = "dDzeE"
Output: "dD"
Explanation: Both "dD" and "eE" are the longest nice substrings.
As there are multiple longest nice substrings, return "dD" since it occurs earlier.


class Solution:
  def longestNiceSubstring(self, s):
    if len(s) < 2:
      return ''
    char = set(s)
    for i in range(len(s)):
      if not (s[i].upper in char and s[i].lower in char):
        s1 = self.longestNiceSubstring(s[:i])
        s2 = self.longestNiceSubstring(s[i+1:])
        return s2 if len(s2) > len(s1) else s1
    return s


## 1876 Substrings of Size Three with Distinct Characters

class Solution:
  def countGoodSubstrings(self, s: str) -> int:
    count = 0
    for i in range(len(s)-2):
      if len(set(s[i:i+3])) == 3:
        count += 1
    return count

## 643 Maximum Average Subarray I
You are given an integer array nums consisting of n elements, and an integer k.
Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. 
Any answer with a calculation error less than 10-5 will be accepted.

Input: nums = [1,12,-5,-6,50,3], k = 4
Output: 12.75000
Explanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75
Input: nums = [5], k = 1
Output: 5.00000


class Solution:
  def findMaxAverage(self, nums: List[int], k:int) -> float:
    s = sum(nums[:k])
    maximum = s
    for i in range(1, len(nums)-k+1):
      s -= nums[i-1]
      s += nums[i+k-1]
      maximum = max(maximum, s)
    return maximum/k


#### 219. Contains Duplicate II
Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.
Input: nums = [1,2,3,1], k = 3
Output: true

Input: nums = [1,2,3,1,2,3], k = 2
Output: false


# Approach 1, Dictionary
class Solution:
  def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool: 
      d = {}
      for i, v in enumerate(nums):
        if v in d and i - d[v] <= k:
          return True
        d[v] = i
      return False

## Approach 2, Sliding Windows
class Solution:
  def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool: 
      windows = set()
      for i in range(0 , len(nums)):
        if len(windows) >= k+1:
          window.remove(nums[i-k-1])
        if nums[i] in windows:
          return True
        windows.add(nums[i])
      return False

## 1176 Diet Plan Performance

A dieter consumes calories[i] calories on the i-th day. 
Given an integer k, for every consecutive sequence of k days (calories[i], calories[i+1], ..., calories[i+k-1] for all 0 <= i <= n-k), they look at T, 
the total calories consumed during that sequence of k days (calories[i] + calories[i+1] + ... + calories[i+k-1]):
If T < lower, they performed poorly on their diet and lose 1 point; 
If T > upper, they performed well on their diet and gain 1 point;
Otherwise, they performed normally and there is no change in points.
Initially, the dieter has zero points. Return the total number of points the dieter has after dieting for calories.length days.
Note that the total points can be negative.

Input: calories = [1,2,3,4,5], k = 1, lower = 3, upper = 3
Output: 0
Explanation: Since k = 1, we consider each element of the array separately and compare it to lower and upper.
calories[0] and calories[1] are less than lower so 2 points are lost.
calories[3] and calories[4] are greater than upper so 2 points are gained.

Input: calories = [3,2], k = 2, lower = 0, upper = 1
Output: 1
Explanation: Since k = 2, we consider subarrays of length 2.
calories[0] + calories[1] > upper so 1 point is gained.

class Solution:
  def dietPlanPerformance(self, calories: List[int], k: int, lower:int, upper: int) -> int:
    ans = 0
    T = sum(calories[0:k])
    if T > upper: ans += 1
    if T < lower: ans -= 1
    for i in range(1, len(calories)-k+1):
      T -= calories[i-1]
      T += calories[i+k-1]
      if T > upper: ans += 1
      elif T < lower: ans -=1
      else:
        ans += 0
    return ans


## 209 Minimum Size Subarray Sum
Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, ..., numsr-1, numsr] 
of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead.

Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.
 

Input: target = 4, nums = [1,4,4]
Output: 1

Input: target = 11, nums = [1,1,1,1,1,1,1,1]
Output: 0

class Solution:
  def minSubArrayLen(self, target: int, nums: List[int]) -> int:
    left = 0
    right = 0
    total = 0
    ans = len(nums) + 1
    while right < len(nums):
      total += nums[right]
      while total >= target:
        ans = min(ans, right - left + 1)
        total -= nums[left]
        left += 1
      right += 1
    return ans if ans <= len(nums) else 0




## 159 Longest Substring with at Most 2 distinct Characters:

Given a string s, return the length of the longest substring that contains at most two distinct characters.
Input: s = "eceba"
Output: 3
Explanation: The substring is "ece" which its length is 3.

Input: s = "ccaabbb"
Output: 5
Explanation: The substring is "aabbb" which its length is 5.


class Solution:
  def lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:
    d = {}
    n = len(s)
    if n < 3:
      return n
    left = 0
    right = 0
    ans = 2   ## minimum length for 2 distinct chars
    
    while right < n:
      d[s[right]] = right
      right += 1
      
      if len(d) == 3:
        index = min(d.values())
        del d[s[index]]
        left = index + 1
      ans = max(ans, right - left)
    return ans



## 1852. Distinct Numbers in Each Subarray
Given an integer array nums and an integer k, you are asked to construct the array ans of size n-k+1 
where ans[i] is the number of distinct numbers in the subarray nums[i:i+k-1] = [nums[i], nums[i+1], ..., nums[i+k-1]].

Input: nums = [1,2,3,2,2,1,3], k = 3
Output: [3,2,2,2,3]
Explanation: The number of distinct elements in each subarray goes as follows:
- nums[0:2] = [1,2,3] so ans[0] = 3
- nums[1:3] = [2,3,2] so ans[1] = 2
- nums[2:4] = [3,2,2] so ans[2] = 2
- nums[3:5] = [2,2,1] so ans[3] = 2
- nums[4:6] = [2,1,3] so ans[4] = 3

Input: nums = [1,1,1,1,2,3,4], k = 4
Output: [1,2,3,4]
Explanation: The number of distinct elements in each subarray goes as follows:
- nums[0:3] = [1,1,1,1] so ans[0] = 1
- nums[1:4] = [1,1,1,2] so ans[1] = 2
- nums[2:5] = [1,1,2,3] so ans[2] = 3
- nums[3:6] = [1,2,3,4] so ans[3] = 4


class Solution:
  def distinctNumbers(self, nums: List[int], k:int) -> List[int]:
    c = collections.Counter(nums[:k])
    ## c can also = {} and then a for loop through nums[:k]
    res = []
    res.append(len(c))
    for i in range(k, len(nums)):
      if nums[i] in c:
        c[nums[i]] += 1
      else:
        c[nums[i]] = 1
      c[nums[i-k]] -= 1
      if c[nums[i-k]] == 0:
        c.pop(nums[i-k])
      res.append(len(c))
    return res

class Solution:
  def distinctNumbers(self, nums:List[int], k:int) -> List[int]:
    c = collections.Counter(nums[:k])
    cur = len(c)
    res = [cur]
    
    for i in range(k, len(nums)):
      c[nums[i-k]] -= 1
      if c[nums[i-k]] == 0:
        cur -= 1
      if c[nums[i]] == 0:
        cur += 1
      c[nums[i]] += 1
      res.append(cur)
    return res
      
## 1100 Find K-length Substrings With No Repeated Characters
Given a string s and an integer k, return the number of substrings in s of length k with no repeated characters.

Input: s = "havefunonleetcode", k = 5
Output: 6
Explanation: There are 6 substrings they are: 'havef','avefu','vefun','efuno','etcod','tcode'.

Input: s = "home", k = 5
Output: 0
Explanation: Notice k can be larger than the length of s. In this case, it is not possible to find any substring.

## Approach 1
class Solution:
  def numKLenSubstrNoRepeats(self, s: str, k: int) -> int:
    if k > len(s):
      return 0
    c = collections.Counter(s[:k])
    ans = 0
    if max(c.values()) == 1 and len(c) == k:
      ans += 1
    for i in range(k, len(s)):
      if s[i] not in c:
        c[s[i]] = 1
      else:
        c[s[i]] += 1
      c[s[i-k]] -= 1
      if c[s[i-k]] == 0:
        c.pop(s[i-k])
      if len(c) == k and all(value == 1 for value in c.values()):
        ans += 1
      else:
        continue
    return ans

Approach 2
class Solution:
    def numKLenSubstrNoRepeats(self, s: str, k: int) -> int:
        if len(s) < k:
            return 0
        
        self.points = 0
        currString = s[:k]
        self.checkDup(currString)
        
        for i in range(len(s) - k):
            currString = s[i+1:i+k+1]
            self.checkDup(currString)
        
        return self.points 
    
    def checkDup(self, currString):
        if len(currString) == len(set(currString)):
            self.points += 1

## 1343 Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold
Given an array of integers arr and two integers k and threshold.
Return the number of sub-arrays of size k and average greater than or equal to threshold.

Input: arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4
Output: 3
Explanation: Sub-arrays [2,5,5],[5,5,5] and [5,5,8] have averages 4, 5 and 6 respectively. All other sub-arrays of size 3 have averages less than 4 (the threshold).
 

Input: arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5
Output: 6
Explanation: The first 6 sub-arrays of size 3 have averages greater than 5. Note that averages are not integers.

class Solution:
  def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:
    sub_arr = sum(arr[:k])
    ans = 0
    l = k * threshold
    if sub_arr >= l:
      ans += 1
    for i in range(k, len(arr)):
      sub_arr -= arr[i-k]
      sub_arr += arr[i]
      if sub_arr >= l:
        ans += 1
    return ans



## 1358 Number of Substrings Containing All Three Characters:
Given a string s consisting only of characters a, b and c.
Return the number of substrings containing at least one occurrence of all these characters a, b and c.

Input: s = "abcabc"
Output: 10
Explanation: The substrings containing at least one 
occurrence of the characters a, b and c are "abc", "abca", "abcab", "abcabc", "bca", "bcab", "bcabc", "cab", "cabc" and "abc" (again). 

Input: s = "aaacb"
Output: 3
Explanation: The substrings containing at least one occurrence of the characters a, b and c are "aaacb", "aacb" and "acb". 

#################################################
Maintain a window which contains at least each character of a, b and c.
Once we found a window, rest part of that window will be a valid count.
So we can add len(s) - i on it.
################################################
class Solution:
  j = 0
  result = 0
  d = collections.Counter()
  for i, char in enumerate(s):
    d[char] += 1
    while len(d) == 3:
      result += len(s) - i
      d[s[j]] -= 1
      if d[s[j]] == 0:
        del d[s[j]]
      j += 1
  return result

## 1004. Max Consecutive Ones III
Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.

Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
Output: 6
Explanation: [1,1,1,0,0,1,1,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.

Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
Output: 10
Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
## My approach
class Solution:
  def longestOnes(self, nums: List[int], k:int) -> int:
    max_l = 0
    left = 0
    right = 0
    count_zero = 0
    while right < len(nums):
      if nums[right] == 0:
        count_zero += 1
      if count_zero <= k:
        max_l = max(max_l, right - left + 1)
      right += 1
      while count_zero > k:
        if nums[left] == 0:
          count_zero -= 1
        left += 1
   return max_l
  
#### Approach 2    
class Solution:
  left = right = 0
  for right in range(len(nums)):
    if nums[right] == 0:
      k -= 1
    if k < 0:
      if nums[left] == 0:
        k += 1
      left += 1
  return right - left + 1
    
    
## 1493. Longest Subarray of 1's after deleting 1 element
Given a binary array nums, you should delete one element from it.
Return the size of the longest non-empty subarray containing only 1's in the resulting array.
Return 0 if there is no such subarray.

Input: nums = [1,1,0,1]
Output: 3
Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.

Input: nums = [0,1,1,1,0,1,1,0,1]
Output: 5
Explanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1].

Input: nums = [1,1,1]
Output: 2
Explanation: You must delete one element.

Input: nums = [1,1,0,0,1,1,1,0,1]
Output: 4

Input: nums = [0,0,0]
Output: 0

class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        left = 0
        k = 1
        for right in range(len(nums)):
            if nums[right] == 0:
                k -= 1
            if k < 0:
                if nums[left] == 0:
                    k += 1
                left += 1
        return right - left 

## 1151. Minimum Swaps to Group All 1's Together
Given a binary array data, return the minimum number of swaps required to group all 1â€™s present in the array together in any place in the array.

Input: data = [1,0,1,0,1]
Output: 1
Explanation: 
There are 3 ways to group all 1's together:
[1,1,1,0,0] using 1 swap.
[0,1,1,1,0] using 2 swaps.
[0,0,1,1,1] using 1 swap.
The minimum is 1.

Input: data = [0,0,0,1,0]
Output: 0
Explanation: 
Since there is only one 1 in the array, no swaps needed.


class Solution:
  def minSwaps(self, data: List[int]) -> int:
    d = collections.Counter(data)
    if d[1] == 0 or d[1] == 1:
      return 0
    window = d[1]
    left = 0
    right = 0 
    count = 0
    ans = float('inf')
    while right < len(data):
      if data[right] ==0:
        count += 1
      if right - left + 1 == window:
        ans = min(ans, count)
        if data[left] == 0:
          count -= 1
        left += 1
      right += 1
    return ans



##487 Max Consecutive Ones II
Given a binary array nums, return the maximum number of consecutive 1's in the array if you can flip at most one 0.

Input: nums = [1,0,1,1,0]
Output: 4
Explanation: Flip the first zero will get the maximum number of consecutive 1s. After flipping, the maximum number of consecutive 1s is 4.

class Solution:
  def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
     left = 0
     right = 0
     ans = 0
     count = 0
     
     while right < len(nums):
        if nums[right] == 0:
          count += 1
        while count > 1:
          if nums[left] == 0:
            count -=1
          left += 1
        ans = max(ans, right - left + 1)
      right += 1
    return ans


##1248 Count Number of Nice Subarrays
Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.
Return the number of nice sub-arrays.

Input: nums = [1,1,2,1,1], k = 3
Output: 2
Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].

Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2
Output: 16

## Note, we need another count for the combinations compare to the traditional sliding windows


class Solution:
  def numberOfSubarrays(self, nums: List[int], k: int) -> int:
    left = 0
    right = 0
    ans = 0
    cur_sub_count = 0
    count_odd = 0
    
    for right in range(len(nums)):
      if nums[right] % 2 == 1:
        count_odd += 1
        cur_sub_count = 0
      while count_odd == k:
        if nums[left] % 2 == 1:
          count_odd -= 1
        cur_sub_count += 1
        left += 1
     ans += cur_sub_count
    return ans


##1052 Grumpy Bookstore Owner
There is a bookstore owner that has a store open for n minutes. Every minute, some number of customers enter the store. 
You are given an integer array customers of length n where customers[i] is the number of the customer that enters the store at the start of 
the ith minute and all those customers leave after the end of that minute.
On some minutes, the bookstore owner is grumpy. You are given a binary array grumpy where grumpy[i] is 1 if the bookstore owner is grumpy during the ith minute, 
and is 0 otherwise.
When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise, they are satisfied.
The bookstore owner knows a secret technique to keep themselves not grumpy for minutes consecutive minutes, but can only use it once.
Return the maximum number of customers that can be satisfied throughout the day.

Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3
Output: 16
Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. 
The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.

Input: customers = [1], grumpy = [0], minutes = 1
Output: 1

class Solution:
  def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:
      left = 0
      right = minutes
      cursum = 0
      maxsum = 0
      for i in range(len(customers)):
        if grumpy[i] == 0:
          cursum += customers[i]
      ## start the first window
      for i in range(minutes):
        if grumpy[i] != 0:
          cursum += customers[i]
      maxsum = cursum
      while right < len(customers):
        if grumpy[right] !=0:
          cursum += customers[right]
        if grumpy[left] != 0:
          cursum -= customers[left]
        maxsum = max(maxsum, cursum)
        right += 1
        left += 1
      return maxsum
      
      
## 1456. Maximum Number of Vowels in a Substring of Givern Length
Given a string s and an integer k.
Return the maximum number of vowel letters in any substring of s with length k.
Vowel letters in English are (a, e, i, o, u).

Input: s = "abciiidef", k = 3
Output: 3
Explanation: The substring "iii" contains 3 vowel letters.

Input: s = "aeiou", k = 2
Output: 2
Explanation: Any substring of length 2 contains 2 vowels.
class Solution:
    def maxVowels(self, s: str, k: int) -> int:
        count = 0
        vowel = {'a','e','i','o','u'}
        for i in s[0:k]:
            if i in vowel:
                count += 1
        max_vowel = count
        for right in range(k,len(s)):
            if s[right-k] in vowel:
                count -= 1
            if s[right] in vowel:
                count += 1
            max_vowel = max(max_vowel, count)
        return max_vowel



##b 1695 Maximum Erasure Value
You are given an array of positive integers nums and want to erase a subarray containing unique elements. 
The score you get by erasing the subarray is equal to the sum of its elements.
Return the maximum score you can get by erasing exactly one subarray.
An array b is called to be a subarray of a if it forms a contiguous subsequence of a, that is, if it is equal to a[l],a[l+1],...,a[r] for some (l,r).

Input: nums = [4,2,4,5,6]
Output: 17
Explanation: The optimal subarray here is [2,4,5,6].

Input: nums = [5,2,1,2,5,2,1,2,5]
Output: 8
Explanation: The optimal subarray here is [5,2,1] or [1,2,5].

class Solution:
  def maximumUniqueSubarray(self, nums: List[int]) -> int:
    s =set()
    left = 0
    right = 0
    max_score = 0
    score = 0
    while right < len(nums):
      if nums[right] not in s:
        score += nums[right]
        s.add(nums[right])
        right += 1
        max_score = max(max_score, score)
      else:
        score -= nums[left]
        s.remove(nums[left])
        left += 1
   return max_score


## 438 Find All Anagrams in a String
Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

Input: s = "cbaebabacd", p = "abc"
Output: [0,6]
Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".

Input: s = "abab", p = "ab"
Output: [0,1,2]
Explanation:
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".

class Solution:
  def finAnagrams(self, s: str, p: str) -> List[int]:
    window = len(p)
    N = len(s)
    d = collections.Counter(p)
    a = collections.Counter()
    res = []
    for i in range(0, N):
      a[s[i]] += 1
      if i >= window:
        if a[s[i-window]] == 1:
          del a[s[i- window]]
        a[s[i- window]] -= 1
      if a == d:
        res.append(i - window + 1)
    return res
    
    
## 1208 Get Equal Substrings Within Budget
You are given two strings s and t of the same length. You want to change s to t. 
Changing the i-th character of s to i-th character of t costs |s[i] - t[i]| that is, the absolute difference between the ASCII values of the characters.
You are also given an integer maxCost.
Return the maximum length of a substring of s that can be changed to be the same as the corresponding substring of twith a cost less than or equal to maxCost.
If there is no substring from s that can be changed to its corresponding substring from t, return 0.

Input: s = "abcd", t = "bcdf", maxCost = 3
Output: 3
Explanation: "abc" of s can change to "bcd". That costs 3, so the maximum length is 3.

 
Input: s = "abcd", t = "acde", maxCost = 0
Output: 1
Explanation: You can't make any change, so the maximum length is 1.


class Solution:
  def equalSubstring(self, s:str, t:str, maxCost:int) -> int:
    i = 0 
    for j in range(len(s)):
      maxCost -= abs(ord(s[j]) - ord(t[j]))
      if maxCost < 0:
        maxCost += abs(ord(s[i]) - ord(t[i]))
        i += 1
    return j - i + 1







    
    
    
    
   

## 1031 Maximum Sum of Two Non-Overlapping Subarrays
Given an integer array nums and two integers firstLen and secondLen, 
return the maximum sum of elements in two non-overlapping subarrays with lengths firstLen and secondLen.
The array with length firstLen could occur before or after the array with length secondLen, but they have to be non-overlapping.
A subarray is a contiguous part of an array.

Input: nums = [0,6,5,2,2,5,1,9,4], firstLen = 1, secondLen = 2
Output: 20
Explanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2.

Input: nums = [3,8,1,3,2,1,8,9,0], firstLen = 3, secondLen = 2
Output: 29
Explanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2.

Input: nums = [2,1,5,6,0,9,5,0,3,8], firstLen = 4, secondLen = 3
Output: 31
Explanation: One choice of subarrays is [5,6,0,9] with length 4, and [3,8] with length 3.

################ Think about prefix sum and sliding window


class Solution:
  def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:
    if len(nums) < firstLen + secondLen:
      return 0
    for i in range(1, len(nums)):
      nums[i] += nums[i-1]
    max_f_len = nums[firstLen -1]
    max_s_len = nums[secondLen - 1]
    res = nums[firstLen + secondLen -1]
    
    for i in range(firstLen + secondLen, len(nums)):
      max_f_len = max(max_f_len, nums[i-secondLen] - nums[i-secondLen - firstLen])
      max_s_len = max(max_s_len, nums[i-firstLen] - nums[i - firstLen - secondLen])
      res = max(res, max_s_len + nums[i] - nums[i - firstLen], max_f_len + nums[i] - nums[i-secondLen])
    return res





## 1918 Kth Smallest Subarray Sum

Given an integer array nums of length n and an integer k, return the kth smallest subarray sum.
A subarray is defined as a non-empty contiguous sequence of elements in an array. A subarray sum is the sum of all elements in the subarray.
Input: nums = [2,1,3], k = 4
Output: 3
Explanation: The subarrays of [2,1,3] are:
- [2] with sum 2
- [1] with sum 1
- [3] with sum 3
- [2,1] with sum 3
- [1,3] with sum 4
- [2,1,3] with sum 6 
Ordering the sums from smallest to largest gives 1, 2, 3, 3, 4, 6. The 4th smallest is 3.

Input: nums = [3,3,5,5], k = 7
Output: 10
Explanation: The subarrays of [3,3,5,5] are:
- [3] with sum 3
- [3] with sum 3
- [5] with sum 5
- [5] with sum 5
- [3,3] with sum 6
- [3,5] with sum 8
- [5,5] with sum 10
- [3,3,5], with sum 11
- [3,5,5] with sum 13
- [3,3,5,5] with sum 16
Ordering the sums from smallest to largest gives 3, 3, 5, 5, 6, 8, 10, 11, 13, 16. The 7th smallest is 10.
 
## Think about sliding window and binary search
##############################################################################################################################
Explanation
Based on the hint section, we can find number of subarray-sum less than x, so that local the kth smallest number among all subarrays using binary search.
Imagine we find all subarray-sum for some array and sort them, the kth smallest subarray-sum, will lay between the minimum sum and the maximum sum.
We don't necessarily need to find all subarray-sum, nor sort them
Instead, since we know the range, we can use binary search to locate the kth smallest
Essentially, using a binary search is to eliminate the subarray-sums which contains more than k values
At the of the binary search, the lower & upper bound will crossover.
The lower bound tells us, there are k sums that less than this lower bound, which makes this lower bound the kth smallest value, or the largest among these k sums.
To find number of subarray-sum less than x, we can iterate the array while maintaining two pointers to count how many valid subarrays are there. 
The time complexity of this process is O(n) because each element is visited twice at max. (n is the length of the array)
Time complexity: O(Nlog(N)), where N is the length of the array. Binary search takes O(log(N*(N+1)/2)) = O(log(N^2)) = O(2logN) = O(logN). 
Finding subarray-sum less than x takes O(N) as mentioned before.
Space Complexity: O(1)
################################################################################################################################

 class Solution:
  def kthSmallestSubarraySum(self, nums: List[int], k:int) -> int:
    lo = min(nums)
    hi = sum(nums)
    while lo <= hi:
      mid = lo + (hi-lo)//2
      if k <= self.number_of_subarray_smaller_than_x(mid, nums):
        hi = mid -1
      else:
        lo = mid +1
    return lo
  
  def number_of_subarray_smaller_than_x(self, x , nums):
    j = 0
    count = 0
    cur = 0
    for i in range(len(nums)):
      cur += nums[i]
      while cur > x:
        cur -= nums[j]
        j += 1
      count += j-i+1
    return count
        
## 1297 Maximum Number of Occurences of a Substring:
Given a string s, return the maximum number of ocurrences of any substring under the following rules:
The number of unique characters in the substring must be less than or equal to maxLetters.
The substring size must be between minSize and maxSize inclusive.
    
Input: s = "aababcaab", maxLetters = 2, minSize = 3, maxSize = 4
Output: 2
Explanation: Substring "aab" has 2 ocurrences in the original string.
It satisfies the conditions, 2 unique letters and size 3 (between minSize and maxSize).

Input: s = "aaaa", maxLetters = 1, minSize = 3, maxSize = 3
Output: 2
Explanation: Substring "aaa" occur 2 times in the string. It can overlap.

Input: s = "aabcabcab", maxLetters = 2, minSize = 2, maxSize = 3
Output: 3

Input: s = "abcde", maxLetters = 2, minSize = 3, maxSize = 3
Output: 0

class Solution:
    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:
        res = []
        if minSize == maxSize:
            tmp = s[0:minSize]
            if len(set(tmp)) <= maxLetters:
                res.append(tmp)
            for i in range(minSize, len(s)):
                tmp = tmp[1:]
                tmp += s[i]
                if len(set(tmp)) <= maxLetters:
                    res.append(tmp)
        else:
            tmp1 = s[0:minSize]
            if len(set(tmp1)) <= maxLetters:
                res.append(tmp1)
            for i in range(minSize, len(s)):
                tmp1 = tmp1[1:]
                tmp1 += s[i]
                if len(set(tmp1)) <= maxLetters:
                    res.append(tmp1)
            tmp2 = s[0:maxSize]
            if len(set(tmp2)) <= maxLetters:
                res.append(tmp2)
            for i in range(maxSize, len(s)):
                tmp2  = tmp2[1:]
                tmp2 += s[i]
                if len(set(tmp2)) <= maxLetters:
                    res.append(tmp2)
        ans = collections.Counter(res)
        print(ans)
        return max(ans.values()) if ans else 0
                
## 1423 Maximum Points You can Obtain from cards
There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints.
In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards.
Your score is the sum of the points of the cards you have taken.
Given the integer array cardPoints and the integer k, return the maximum score you can obtain.

Input: cardPoints = [1,2,3,4,5,6,1], k = 3
Output: 12
Explanation: After the first step, your score will always be 1. 
However, choosing the rightmost card first will maximize your total score. 
The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12.

class Solution:
  def maxScore(self, cardPoints: List[int], k:int) -> int:
    res = sum(cardPoints[:k])
    ans = res
    
    if k >= len(cardPoints):
      return ans
      
    left = k - 1
    right = -1
    for _ in range(k):
      res = res - cardPoints[left] + cardPoints[right]
      ans = max(ans, res)
      right -= 1
      left -= 1
    return ans
    
    











    
    







